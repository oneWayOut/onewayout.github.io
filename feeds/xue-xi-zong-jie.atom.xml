<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>NutShellKing Blog - 学习总结</title><link href="https://oneWayOut.github.io/" rel="alternate"></link><link href="https://oneWayOut.github.io/feeds/xue-xi-zong-jie.atom.xml" rel="self"></link><id>https://oneWayOut.github.io/</id><updated>2017-12-02T00:00:00+08:00</updated><entry><title>Pixhawk连接摇杆进行仿真</title><link href="https://oneWayOut.github.io/articles/xue-xi-zong-jie/pixhawk_joystick/" rel="alternate"></link><published>2017-12-02T00:00:00+08:00</published><updated>2017-12-02T00:00:00+08:00</updated><author><name>oneWayOut</name></author><id>tag:onewayout.github.io,2017-12-02:/articles/xue-xi-zong-jie/pixhawk_joystick/</id><summary type="html">&lt;p&gt;对Pixhawk代码中的仿真接口模块进行了更改，使其能够直接通过USB接口读取控制摇杆的输入，实现对其飞控代码的仿真飞行控制&lt;/p&gt;</summary><content type="html">&lt;h3 id="1"&gt;1. 问题&lt;/h3&gt;

&lt;p&gt;最近有这样一个需求: 对Pixhawk软件中的控制算法进行更改后，需要对其控制算法、各模式间的切换等进行全面地仿真测试，避免实际飞行时炸机的损失。
按照&lt;a href="https://dev.px4.io/en/simulation/"&gt;官方文档中的方法&lt;/a&gt;， 可利用Gazebo, QGroundControl等配合完成大部分的大部分的测试，还可连接控制摇杆/手柄(Joystick/Gamepad), 将其作为手动输入。同事付老师帮忙给了一个Made in China的Saitek Cyborg evo摇杆，按照官网方法进行配置，发现在仿真中无法通过其设置手动、增稳、自动等飞行模式，一查，原来仅有&lt;a href="https://docs.qgroundcontrol.com/en/SetupView/Joystick.html#sony-playstation-34-controllers"&gt;高端的Sony的摇杆才能支持模式切换&lt;/a&gt;。 只好想办法省钱，通过更改软件解决无法通过摇杆切换模式的问题。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/px4_joystick/Joystick.jpg"　height="400"/&gt;&lt;/center&gt; &lt;/p&gt;
&lt;h3 id="2"&gt;2. 问题分析&lt;/h3&gt;

&lt;p&gt;PX4原有的仿真环境交联关系如下图：
&lt;center&gt;&lt;img src="/images/px4_joystick/SITL1.png"　height="448"/&gt;&lt;/center&gt; 
从图中可以看出摇杆的输入通过QGroundControl地面站读取后，转发给控制软件。若能通过控制软件直接读取摇杆输入，如下图：
&lt;center&gt;&lt;img src="/images/px4_joystick/SITL2.png" height="448"/&gt;&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在控制软件中读取摇杆输入后，对其解析，将按键消息打包为软件能识别的模式切换指令消息，并按照PX4软件中的消息发布订阅机制将其发送至负责模式切换的模块，即能解决前述问题。因此须分以下两步达到目标:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取摇杆输入，正确解析其消息；&lt;/li&gt;
&lt;li&gt;将摇杆消息打包为软件可识别的Topic, 将其发布；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事后想了一下官网中通过QGroundControl转发摇杆数据，而非通过控制软件直接读取的原因可能如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方便对不同摇杆进行校准操作. 因最终软件需要的控制量数据均需要进行归一化处理, 可通过QGroundControl对不同类型摇杆进行统一校准操作；&lt;/li&gt;
&lt;li&gt;可保持软件的通用性，在SITL, HITL, 或实际飞行时均可通过Joystick控制飞行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3"&gt;3. 解决方案&lt;/h3&gt;

&lt;h4 id="3.1"&gt;3.1. 读取摇杆输入&lt;/h4&gt;

&lt;p&gt;首选需要弄清如何读取摇杆输入. 以谷歌找到的一个&lt;a href="https://www.kernel.org/doc/Documentation/input/joystick-api.txt"&gt;linux官方文档&lt;/a&gt;及&lt;a href="https://github.com/drewnoakes/joystick"&gt;代码工程&lt;/a&gt;为参考，写了如下一个简单测试程序读取摇杆输入，测试环境为Ubuntu 16.04LTS.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#define JS_EVENT_BUTTON 0x01 &lt;/span&gt;&lt;span class="c1"&gt;// button pressed/released&lt;/span&gt;
&lt;span class="cp"&gt;#define JS_EVENT_AXIS   0x02 &lt;/span&gt;&lt;span class="c1"&gt;// joystick moved&lt;/span&gt;
&lt;span class="cp"&gt;#define JS_EVENT_INIT   0x80 &lt;/span&gt;&lt;span class="c1"&gt;// initial state of device&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* event timestamp in milliseconds */&lt;/span&gt;
    &lt;span class="kt"&gt;short&lt;/span&gt;         &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="cm"&gt;/* value: for buttons: 1/0 = down/up; axes: -32767~32767*/&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* event type */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* axis/button number */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;JS_EVENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//open the joystick device, the name might be different&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/dev/input/js0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;can not open joystick!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="n"&gt;sbuf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/dev/input/js0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sbuf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/etc/hosts file size = %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sbuf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_rdev&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;JS_EVENT&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Restrict rate&lt;/span&gt;
        &lt;span class="n"&gt;usleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Attempt to sample an event from the joystick&lt;/span&gt;
        &lt;span class="n"&gt;bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JS_EVENT&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JS_EVENT&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;JS_EVENT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Button %u  is %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;up&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;down&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;JS_EVENT_AXIS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Axis %u is at position %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用如下命令编译&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;g++ -g -o readJoy main.cpp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过USB连接Saitek Cyborg evo摇杆, 执行程序,得到如下结果:
&lt;center&gt;&lt;img src="/images/px4_joystick/readJoyStick.png"/&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;代码中通过JS_EVENT结构体读取数据，该数据结构中的type表示了摇杆事件类型(轴移动或按键)， 而number和value则分别表示了哪一个轴/按键的事件值。
拟通过摇杆的各轴作为roll, pitch, yaw, throttle控制，以按键控制模式切换。为了进行下一步工作，须测试得出各轴的极限位置下软件采到的事件值: &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Axis&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Direction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;axis0&lt;/td&gt;
&lt;td&gt;Roll&lt;/td&gt;
&lt;td&gt;-32767~32767&lt;/td&gt;
&lt;td&gt;left~right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;axis1&lt;/td&gt;
&lt;td&gt;Pitch&lt;/td&gt;
&lt;td&gt;32767~-32767&lt;/td&gt;
&lt;td&gt;backward~forward&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;axis2&lt;/td&gt;
&lt;td&gt;Throttle&lt;/td&gt;
&lt;td&gt;32767~-32767&lt;/td&gt;
&lt;td&gt;min~max&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;axis3&lt;/td&gt;
&lt;td&gt;Yaw&lt;/td&gt;
&lt;td&gt;-32767~32767&lt;/td&gt;
&lt;td&gt;left~right&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="3.2"&gt;3.2. 修改Pixhawk源码&lt;/h4&gt;

&lt;p&gt;读取解析到摇杆的动作事件数据仅是第一步，为将其集成至Pixhawk中的软件模块，还需注意以下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上述示例代码中的read()函数为阻塞调用，若直接将其放入某个线程中，没有事件发生时，会导致该线程阻塞而无法执行其他语句，须使用linux提供的poll()接口，仅当查询到有事件发生才调用read()读设备文件上的消息;&lt;/li&gt;
&lt;li&gt;须按照Pixhawk的消息订阅/发布(publish/subscribe)机制将摇杆消息打包成软件可识别的消息，在此我们将其打包为&lt;strong&gt;manual_control_setpoint&lt;/strong&gt;消息。因为事实上软件中sensors模块中rc_update.cpp将原始的遥控器消息也解析为&lt;strong&gt;manual_control_setpoint&lt;/strong&gt;消息，并将其发布。位置控制模块订阅该消息，获取其中的各轴控制量信息。特别需要注意的是Commander模块也订阅该消息，在Commander.cpp中的set_main_state_rc()函数中，根据该消息中的模式设置变量设置飞机的模式。需要根据该函数逆推出发生各模式按键事件后，应该给manual_control_setpoint消息中所需填充的正确值，以期得到目标模式。&lt;/li&gt;
&lt;li&gt;按照上述思路更改代码后，发现按压摇杆上对应按键后，有时无法切换模式的问题。排查发现发布消息的频率过快(6ms)，很可能导致消息队列满，使Commander模块无法接收到新消息，从而无法切换模式的问题。将发布消息的周期改为50ms, 该问题再无复现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终通过摇杆上的按键0,1,2分别控制手动、增稳、自动三种模式，以其四个轴(axis)控制滚转、俯仰、偏航及油门。在PX4/Firmware的v1.6.5稳定版代码基础上，对&lt;a href="https://github.com/oneWayOut/Firmware/blob/cai_readJS/src/modules/simulator/simulator_mavlink.cpp"&gt;simulator_mavlink.cpp&lt;/a&gt;文件更改，插入部分代码，均在&lt;strong&gt;#ifdef ENABLE_JOYSTICK ... #endif&lt;/strong&gt; 预处理块内，详见https://github.com/oneWayOut/Firmware上的&lt;a href="https://github.com/oneWayOut/Firmware/tree/cai_readJS"&gt;cai_readJS&lt;/a&gt;分支。&lt;/p&gt;
&lt;p&gt;在代码目录的终端中输入以下命令，可对其进行测试:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;make posix gazebo_plane
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;连接QGroundControl后，即可模拟飞行操作。&lt;/p&gt;</content><category term="Pixhawk"></category><category term="Joystick"></category><category term="Simulation"></category><category term="摇杆， 仿真"></category></entry><entry><title>博客迁移笔记</title><link href="https://oneWayOut.github.io/articles/xue-xi-zong-jie/move_blog/" rel="alternate"></link><published>2017-05-07T00:00:00+08:00</published><updated>2017-05-07T00:00:00+08:00</updated><author><name>oneWayOut</name></author><id>tag:onewayout.github.io,2017-05-07:/articles/xue-xi-zong-jie/move_blog/</id><summary type="html">&lt;p&gt;记录了博客从Jekyll迁移至Pelican的过程中解决的几个问题&lt;/p&gt;</summary><content type="html">&lt;p&gt;去年花了一些时间在github上建起了&lt;a href="http://onewayout.github.io"&gt;个人博客&lt;/a&gt;，后来又购买了&lt;a href="http://nutshellking.com"&gt;域名nutshellking.com&lt;/a&gt;(取自哈姆雷特台词I could be bounded in a &lt;strong&gt;nutshell&lt;/strong&gt;, and count myself a &lt;strong&gt;king&lt;/strong&gt; of infinite space), 该博客采用Jekyll生成，基本满足了我想要的如下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码高亮；&lt;/li&gt;
&lt;li&gt;支持数学公式显示(通过Mathjax实现)；&lt;/li&gt;
&lt;li&gt;支持评论（通过Disqus实现，后来发现此项功能被GFW屏蔽了）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自那以后，一直瞎忙，没时间打理博客，近来兴起，想将个人博客网站更新重整。此博客原来使用的Jekyll是一个Ruby语言写成的静态网页生成器, 因觉得Ruby用途较为单一，最近在学应用广泛的Python的缘故，觉得将博客迁移至基于Python技术的Web框架应该会比较有趣。比较成熟的Python Web框架要数Flask与Django了。对于一个简洁的博客，Django可能太过重量级，Flask就够用了，因此买了本《Flask Web开发　基于Python的Web应用开发实战》（人称Flask狗书），在电脑上演练一番。在此过程中填了不少坑，浪费了不少时间，最终转到与Jekyll十分类似的Pelican上面。将此段时间的折腾记录如下。&lt;/p&gt;
&lt;p&gt;Flask狗书循序渐进的讲述了Flask开发的各个步骤，结合其提供的&lt;a href="https://github.com/miguelgrinberg/flasky"&gt;git代码库&lt;/a&gt;能够按章节一步步实现、理解所需功能，实为良心之作。该书作者作为Flask的核心开发者，其个人网站上也有一个讲解&lt;a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world"&gt;Flask的教程&lt;/a&gt;很不错。但Flask仅仅只是一个框架，要将其变为可部署的个人博客产品显然需要定制各种插件，加入个性化配置，有很多工作要做。这也是我最初始料未及的。
&lt;h2 id="1"&gt;1. Flask　Web开发实战书中的几个问题&lt;/h2&gt;
&lt;h3 id="1.1"&gt;1.1 注册时无法通过email收到激活邮件&lt;/h3&gt;
第8章中用户注册功能需要用向注册的用户发送激活邮件，此步骤要求必须实现配置好邮件发送相关设置，代码中默认的设置使用google的邮件服务，不更改此处显然无法成功。
该设置在Config.py中，以第9章的程序为例, 首先签出对应版本:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/miguelgrinberg/flasky.git
&lt;span class="nb"&gt;cd&lt;/span&gt; flasky
git checkout 9a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意Config.py中以下代码:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;MAIL_SERVER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smtp.googlemail.com&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;MAIL_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;587&lt;/span&gt;
    &lt;span class="n"&gt;MAIL_USE_TLS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="n"&gt;MAIL_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;MAIL_USERNAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;MAIL_PASSWORD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;MAIL_PASSWORD&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;FLASKY_MAIL_SUBJECT_PREFIX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[Flasky]&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;FLASKY_MAIL_SENDER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Flasky Admin &amp;lt;flasky@example.com&amp;gt;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;FLASKY_ADMIN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;FLASKY_ADMIN&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若使用163邮箱，可更改其MAIL_SERVER及MAIL_PORT如下（其他邮箱可参考email服务商官网帮助）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;MAIL_SERVER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smtp.163.com&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;MAIL_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并将flasky@example.com替换为自己所用邮箱。注意到以上代码中使用了这几个环境变量: MAIL_USERNAME，MAIL_PASSWORD，FLASKY_ADMIN，在linux环境下，需在终端中对其进行设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;venv&lt;span class="o"&gt;)&lt;/span&gt; $ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;MAIL_USERNAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;mail username&amp;gt;
&lt;span class="o"&gt;(&lt;/span&gt;venv&lt;span class="o"&gt;)&lt;/span&gt; $ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;MAIL_PASSWORD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;mail password&amp;gt;
&lt;span class="o"&gt;(&lt;/span&gt;venv&lt;span class="o"&gt;)&lt;/span&gt; $ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;mail username&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若为Windows环境，将export改为set。
注意在终端中输入的邮箱用户名不需要再加上@xxx.com后缀。&lt;/p&gt;
&lt;h3 id="1.2"&gt;1.2 无法发表文章&lt;/h3&gt;

&lt;p&gt;第11章时会出现使用管理员账户登录后无法发表文章的问题，此问题的原因是数据库中角色权限不对。可参考&lt;a href="https://www.zhihu.com/question/42493758"&gt;此处解决方案&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="1.3"&gt;1.3 markdown生成的网页文件显示不正常&lt;/h3&gt;

&lt;p&gt;按照该书提供源码，使用markdown编写文件，插入如下表格格式的文本，预览时发现无法显示表格。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Item     | Value
-------- | ---
Computer | $1600
Phone    | $12
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是由于python的markdown模块将文本转换为网页文件时，未指定使用相应扩展所致。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git checkout 11h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按以上指令检出文件，找到app/models.py中的on_changed_body函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_changed_body&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oldvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initiator&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;allowed_tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;abbr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;acronym&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blockquote&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="s1"&gt;&amp;#39;em&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;pre&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;strong&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ul&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="s1"&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;h2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;h3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;p&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body_html&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bleach&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linkify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bleach&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output_format&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="n"&gt;tags&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;allowed_tags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将此段代码改为如下即可:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_changed_body&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oldvalue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initiator&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;myexts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;extra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;abbr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;attr_list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;def_list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fenced_code&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;footnotes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tables&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smart_strong&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;admonition&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;codehilite&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;headerid&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;meta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;nl2br&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;sane_lists&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smarty&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;toc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body_html&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bleach&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linkify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extensions&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myexts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;markdown模块的各个扩展的用法可参考&lt;a href="http://pythonhosted.org/Markdown/extensions/"&gt;此处官网&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="2"&gt;2 Pelican中markdown文件插入数学公式无法正确显示&lt;/h2&gt;

&lt;p&gt;Pelican的使用还是相当方便的，但其依赖的Python　Markdown模块转换markdown文件的能力没有Jekyll成熟稳定。借助Mathjax脚本在markdown文件中插入Latex数学公式时，若公式中含有下划线_:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$$\vec{X} = (\vec{x_j}, \vec{x_k})$$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则下划线在转换后会生成&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签，导致无法正确渲染公式。　
解决此问题需要在调用markdown解析转换文件时，碰到$$等符号换种规则解析即可。网上已有&lt;a href="https://github.com/mayoff/python-markdown-mathjax"&gt;解决方案&lt;/a&gt;，就无须重造轮子了。按照该方案将mathjax.py拷贝至markdown模块中的extensions子文件夹中，然后在pelicanconf.py中添加以下代码即可:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;MARKDOWN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;extension_configs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;markdown.extensions.codehilite&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;css_class&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;highlight&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;markdown.extensions.extra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;markdown.extensions.meta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;markdown.extensions.mathjax&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;output_format&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;html5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;填了这么多坑，费了很多时间终于讲博客迁移成功。希望能够继续坚持探索、记录、分享自己的各种想法。&lt;/p&gt;</content><category term="博客"></category><category term="pelican"></category><category term="flask"></category><category term="markdown"></category></entry><entry><title>Pixhawk多旋翼姿态控制算法解析</title><link href="https://oneWayOut.github.io/articles/xue-xi-zong-jie/Pixhawk_attitude_control/" rel="alternate"></link><published>2016-07-02T00:00:00+08:00</published><updated>2017-05-07T00:00:00+08:00</updated><author><name>oneWayOut</name></author><id>tag:onewayout.github.io,2016-07-02:/articles/xue-xi-zong-jie/Pixhawk_attitude_control/</id><summary type="html">&lt;p&gt;本文介绍了飞行控制用到的一些基础数学知识，并结合Pixhawk源代码详细解析了其多旋翼姿态控制算法。&lt;/p&gt;</summary><content type="html">&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
},
messageStyle: "none",
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
&lt;/script&gt;

&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;

&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;

&lt;p&gt;网上有些关于Pixhawk姿态控制的文章, 写的都不是很透彻清晰. 因为其姿态控制算法中计算各姿态轴误差的部分代码看起来很是晦涩，很难在教科书或网上找到相关资料，纯粹是开发者自己的经验想法，我所能找到的中文资料基本上没有讲清这一点. 最近在研究Pixhawk多旋翼飞控，现已基本明白其姿态控制原理, 在本文中力图简明地阐述我的理解. &lt;/p&gt;
&lt;p&gt;我在之前的&lt;a href="http://onewayout.github.io/pixhawk/2016/05/24/pixhawk-principle-and-customize.html#1.5"&gt;这篇文章&lt;/a&gt;已对Pixhawk总体架构做了一个概括. 理解了代码架构、控制率，想要利用pixhawk强大的软硬件平台来扩展做自己想要的东西就相当简单了. 大部分个性化的定制应该在控制率、仿真上面. 比如我们新设计了一个异型翼面，控制通道与现有飞机不同的飞机，仅需要在原有控制率上修改或新实现自己的控制率，并更改相关启动脚本及mixer文件就可以了. 而姿态估计、位置估计等模块可不做任何更改完全复用，这也是Pixhawk中通过消息发布/订阅模式来实现模块间通信，从而达到高度模块化的软件架构带来的好处. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1"&gt;1. 前置知识&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.1"&gt;1.1 旋转矩阵的含义&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2"&gt;1.2 飞机姿态控制中用到的几种旋转表示方法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2.1"&gt;1.2.1 坐标系约定&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2.2"&gt;1.2.2 欧拉角表示&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2.3"&gt;1.2.3 四元数表示&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2.4"&gt;1.2.4 罗德里格旋转公式&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.3"&gt;1.3 姿态误差的求取&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2"&gt;2. Pixhawk姿态控制解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.1"&gt;2.1 Pixhawk飞控架构&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.2"&gt;2.2 Pixhawk姿态控制代码解析&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.2.1"&gt;2.2.1 角度误差控制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.2.2"&gt;2.2.2 角速率误差控制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="1"&gt;1. 前置知识&lt;/h2&gt;

&lt;p&gt;姿态控制需要用到空间旋转，矩阵等知识，网上教程很多，鱼龙混杂难以取舍，我在这里尽量以最简明的语言阐释所有需要用到的知识（KISS原则, 你懂的^_^）. &lt;/p&gt;
&lt;h3 id="1.1"&gt;1.1 旋转矩阵的含义&lt;/h3&gt;

&lt;p&gt;矩阵可表示两个向量间关系，有两种惯例来表示旋转矩阵的意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在固定坐标系下对向量进行旋转，旋转前坐标向量和旋转后坐标向量的关系；&lt;/li&gt;
&lt;li&gt;对坐标系进行旋转，同一个向量在两个坐标系下坐标向量的关系；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们将先以简单的二维旋转为例对上述两种意义逐一阐述，三维空间旋转矩阵不过多了一个维度，其意义相同. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种表示意义：旋转向量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/pixhawk_control_law/01RotationMatrix_1000.gif" alt = "RotationMatrix" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;平面上的每一点 ${\displaystyle P}$都有一个坐标 ${\displaystyle P(x,y)}$，并对应着一个向量${\displaystyle (x,y)}$. 所有普通意义上的平面向量组成了一个空间，记作ℝ²，因为每个向量都可以表示为两个实数构成的有序数组${\displaystyle (x,y)}$. 在向量空间ℝ²，将固定坐标系内的给定向量$\mathbf{v_0}$(本例中为$(1,0)^T$)绕逆时针旋转$\theta$至$\mathbf{v’}$(本例中为$(\cos\theta, \sin\theta)^T$), 可表示如下：&lt;/p&gt;
&lt;p&gt;$$\mathbf{v’} = \mathbf{R_\theta}\mathbf{v_0}$$&lt;/p&gt;
&lt;p&gt;上式中$\mathbf{R_\theta}$为：&lt;/p&gt;
&lt;p&gt;$$\mathbf{R_\theta} =
{\begin{bmatrix}
\cos\theta &amp;amp; -\sin\theta \\
\sin\theta &amp;amp; \cos\theta
\end{bmatrix}}
$$&lt;/p&gt;
&lt;!-- $$\mathbf{v’} = \mathbf{R'_\theta}\mathbf{v_0}$$

$$\mathbf{R'_\theta} =
{\begin{bmatrix}
\cos\theta &amp; \sin\theta \\
-\sin\theta &amp; \cos\theta
\end{bmatrix}}
$$--&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二种表示意义：旋转坐标系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文着重讨论此种惯例表示，因为在飞机姿态控制中会用到多个坐标系:大地坐标系(惯性系)，机体坐标系(非惯性系)...等, 我们需要知道同一向量(速度, 加速度,角速度等)在这些坐标系之间的转换关系, 理解此种表示法的意义非常重要. &lt;/p&gt;
&lt;p&gt;仍从最简单的二维旋转开始，如下图所示：
&lt;center&gt;&lt;img src="/images/pixhawk_control_law/02RotationMatrixAxes_1000.gif" alt = "RotationMatrixAxes" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;旋转矩阵可以表示不同坐标系下同一向量的坐标之间的关系. 以上图为例: $\mathbf{v_0}=(1,0)^T$及$\mathbf{v’}=(\cos\theta, -\sin\theta)^T$分别是向量&lt;strong&gt;V&lt;/strong&gt;在坐标系OX&lt;sub&gt;0&lt;/sub&gt;Y&lt;sub&gt;0&lt;/sub&gt;及OX'Y'中的向量坐标，则有:&lt;/p&gt;
&lt;p&gt;$$\mathbf{v_0} = \mathbf{R_\theta}\mathbf{v'}$$&lt;/p&gt;
&lt;p&gt;$$\mathbf{R_\theta} =
{\begin{bmatrix}
\cos\theta &amp;amp; -\sin\theta \\
\sin\theta &amp;amp; \cos\theta
\end{bmatrix}}$$&lt;/p&gt;
&lt;p&gt;矩阵中每个元素可视为两个坐标系内坐标轴向量夹角的余弦值，这也是称旋转矩阵为方向余弦矩阵(Direction Cosine Matrix)的原因. &lt;/p&gt;
&lt;p&gt;三维旋转较二维旋转复杂得多. 在三维空间内，以大地坐标系和飞机机体坐标系间的旋转关系为例，设大地坐标系为Oxyz, 机体坐标系为OXYZ（坐标系方向约定见&lt;a href="#1.2.1"&gt;1.2.1节&lt;/a&gt;）, 设&lt;strong&gt;i, j, k&lt;/strong&gt;为大地坐标系内x,y,z轴的单位向量. &lt;strong&gt;I, J, K&lt;/strong&gt;为机体坐标系内X, Y, Z轴的单位向量，向量V在大地坐标系和机体坐标系内的坐标分别为$\mathbf{v^G}$,$\mathbf{v^B}$, 则此两向量的关系如下：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}\mathbf{v^G} = \begin{bmatrix}
\mathbf{v_x^G}  \\
\mathbf{v_y^G}  \\
\mathbf{v_z^G}
\end{bmatrix} = \begin{bmatrix}
\mathbf{i}\cdot\mathbf{I} &amp;amp; \mathbf{i}\cdot\mathbf{J} &amp;amp; \mathbf{i}\cdot\mathbf{K} \\
\mathbf{j}\cdot\mathbf{I} &amp;amp; \mathbf{j}\cdot\mathbf{J} &amp;amp; \mathbf{j}\cdot\mathbf{K} \\
\mathbf{k}\cdot\mathbf{I} &amp;amp; \mathbf{k}\cdot\mathbf{J} &amp;amp; \mathbf{k}\cdot\mathbf{K} 
\end{bmatrix}\begin{bmatrix}
\mathbf{v_x^B}  \\
\mathbf{v_y^B}  \\
\mathbf{v_z^B}
\end{bmatrix} = 
\mathbf{R_B^G}
\mathbf{v^B}\label{1eq}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旋转矩阵$\mathbf{R_B^G}$的每个元素即为两坐标系内坐标轴的夹角余弦值(即&lt;a href="https://zh.wikipedia.org/wiki/数量积"&gt;点乘&lt;/a&gt;). 其三个列向量分别为机体坐标系的X, Y, Z轴在大地坐标系Oxyz内的坐标向量；其三个行向量分别为大地坐标系x, y, z轴在机体坐标系内坐标向量.&lt;/strong&gt; 即：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}\mathbf{R_B^G} = 
\begin{bmatrix}
\mathbf{I^G}  &amp;amp; \mathbf{J^G}  &amp;amp;\mathbf{K^G}
\end{bmatrix} = 
\begin{bmatrix}
\mathbf{i^B}  \\
\mathbf{j^B}  \\
\mathbf{k^B}
\end{bmatrix}\label{2eq}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;旋转矩阵为正交单位阵，其逆矩阵为其转置矩阵:　$\mathbf{R^{T}}=\mathbf{R^{-1}}$. 利用这一性质可在计算机内快速求其逆.  &lt;br&gt;
请务必记清旋转矩阵的含义及其性质, 且不要将两坐标系的转换顺序弄反. &lt;/p&gt;
&lt;p&gt;下节将阐述如何根据各种旋转表示方法计算此矩阵. &lt;/p&gt;
&lt;p&gt;本节参考资料：&lt;br&gt;
&lt;a href="http://mathworld.wolfram.com/RotationMatrix.html"&gt;http://mathworld.wolfram.com/RotationMatrix.html&lt;/a&gt;&lt;br&gt;
&lt;a href="https://gentlenav.googlecode.com/files/DCMDraft2.pdf"&gt;https://gentlenav.googlecode.com/files/DCMDraft2.pdf&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.starlino.com/dcm_tutorial.html"&gt;http://www.starlino.com/dcm_tutorial.html&lt;/a&gt;&lt;br&gt;
Randal W. Beard &amp;amp; Timothy W. McLain &lt;em&gt;Small Unmanned Aircraft: Theory and Practice&lt;/em&gt;   &lt;/p&gt;
&lt;h3 id="1.2"&gt;1.2 飞机姿态控制中用到的几种旋转表示方法&lt;/h3&gt;

&lt;p&gt;在飞控中我们更多地用到三维旋转，这较二维旋转复杂很多，因为二维旋转仅有一个旋转轴(垂直于OXY平面，即Z轴). 三维旋转可绕空间任意轴旋转，二维旋转只是三维旋转的特例. 除了矩阵，我们还可以用四元数、欧拉角等来表示旋转，他们具有一定的等价关系. &lt;/p&gt;
&lt;h4 id="1.2.1"&gt;1.2.1 坐标系约定&lt;/h4&gt;

&lt;p&gt;大地坐标系一般采用&lt;a href="https://en.wikipedia.org/wiki/North_east_down"&gt;NED(North east down)&lt;/a&gt;. &lt;br&gt;
机体坐标系一般定义如下图所示, roll, pitch, yaw轴分别为X, Y, Z轴:
&lt;center&gt;&lt;img src="/images/pixhawk_control_law/04AirplaneAxes.png" alt = "AirplaneAxes" /&gt;&lt;/center&gt;
坐标系方向和旋转方向遵从右手法则. &lt;/p&gt;
&lt;h4 id="1.2.2"&gt;1.2.2 欧拉角表示&lt;/h4&gt;

&lt;p&gt;以欧拉角表示旋转有多种约定，因为对于同一旋转&lt;strong&gt;欧拉角与旋转次序密切相关&lt;/strong&gt;, &lt;a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%8B%89%E8%A7%92#.E5.88.A5.E7.A8.AE.E9.A0.86.E5.BA.8F"&gt;参考此处&lt;/a&gt;. 
航空航天工程中常用&lt;a href="https://en.wikipedia.org/wiki/Euler_angles#Tait.E2.80.93Bryan_angles"&gt;z-y′-x″顺规&lt;/a&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/pixhawk_control_law/03Taitbrianzyx.png" alt = "Taitbrianzyx" /&gt;&lt;/center&gt;
从大地坐标系oxyz旋转到机体坐标系oXYZ的顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绕oz旋转$\psi$;&lt;/li&gt;
&lt;li&gt;绕oy′旋转$\theta$;&lt;/li&gt;
&lt;li&gt;绕ox″(即oX)旋转$\phi$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\psi$，$\theta$，$\phi$即分别为偏航，俯仰，滚转角(yaw, pitch, roll). &lt;/p&gt;
&lt;p&gt;若从机体旋转到大地坐标系，则为相反的顺序和负的旋转方向. &lt;/p&gt;
&lt;p&gt;通过此三个角度可得出旋转矩阵：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}\mathbf{R_B^G} = \begin{bmatrix} c(\psi)c(\theta) &amp;amp; c(\psi)s(\phi)s(\theta) - c(\phi)s(\psi) &amp;amp; s(\phi)s(\psi) + c(\phi)c(\psi)s(\theta) \\ c(\theta)s(\psi) &amp;amp; c(\phi)c(\psi) + s(\phi)s(\psi)s(\theta) &amp;amp; c(\phi)s(\psi)s(\theta) - c(\psi)s(\phi)\\ -s(\theta) &amp;amp; c(\theta)s(\phi) &amp;amp; c(\phi)c(\theta) \end{bmatrix}\label{3eqEulerAngles}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;式中以$c(\alpha)$表示$\cos(\alpha)$, $s(\alpha)$表示$\sin(\alpha)$. &lt;/p&gt;
&lt;!--
http://www.chrobotics.com/library/understanding-euler-angles
此网址中将此公式的矩阵为$$R_I^B$$, 实应为$$R_B^I$$--&gt;

&lt;h4 id="1.2.3"&gt;1.2.3 四元数表示&lt;/h4&gt;

&lt;p&gt;上节使用欧拉角表示两个坐标系间旋转需要旋转三次，而且存在&lt;a href="https://en.wikipedia.org/wiki/Gimbal_lock"&gt;万向锁定问题(Gimbal Lock)&lt;/a&gt;. 而实际任意两个坐标系间可仅通过一次旋转完成，用四元数表示旋转可直观的得出此旋转的旋转轴和旋转角. &lt;/p&gt;
&lt;p&gt;四元数通常可表示为$\mathbb{R}^4$内的一个向量：
$$\mathbf{e} = \begin{pmatrix}
e_0 \\ e_1 \\ e_2 \\ e_3 
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;现以从大地坐标系到机体坐标系的旋转为例说明四元数的定义：设该旋转的旋转轴在大地坐标系内的单位向量为：$(u_x, u_y, u_z)^\mathrm{T}$, 旋转角度为$\Theta$, 可得出四元数的四个元素为：&lt;/p&gt;
&lt;p&gt;$$e_0 = \cos\frac\Theta2$$&lt;/p&gt;
&lt;p&gt;$$\begin{pmatrix}
e_1 \\ e_2 \\ e_3 
\end{pmatrix} = \begin{pmatrix}
u_x \\ u_y \\ u_z
\end{pmatrix}\sin\frac\Theta2
$$&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/四元数与空间旋转"&gt;维基百科中对四元数&lt;/a&gt;表示旋转的推导比较简明，在此不再赘述. &lt;/p&gt;
&lt;!--$$q=e^{\frac\Theta2(u_xi+u_yj+u_zk)}=\cos\frac\Theta2+(u_xi+u_yj+u_zk)\sin\frac\Theta2$$--&gt;

&lt;p&gt;在1.2.2节中我们已经知道通过欧拉角可直接计算出旋转矩阵，实际上通过四元数也可计算出欧拉角，因此四元数、欧拉角、旋转矩阵间可相互转换. &lt;/p&gt;
&lt;p&gt;本节参考资料：&lt;br&gt;
&lt;a href="https://zh.wikipedia.org/wiki/四元数与空间旋转"&gt;https://zh.wikipedia.org/wiki/四元数与空间旋转&lt;/a&gt;&lt;br&gt;
&lt;a href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles"&gt;https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles&lt;/a&gt;&lt;br&gt;
Randal W. Beard &amp;amp; Timothy W. McLain &lt;em&gt;Small Unmanned Aircraft: Theory and Practice&lt;/em&gt;   &lt;/p&gt;
&lt;h4 id="1.2.4"&gt;1.2.4 罗德里格旋转公式&lt;/h4&gt;

&lt;p&gt;若已知旋转轴$\mathbf{u}$(为单位向量)和旋转角度$\Theta$，我们可以通过计算四元数构造出旋转矩阵，但最简便的方法莫过于直接使用&lt;a href="https://zh.wikipedia.org/wiki/罗德里格旋转公式"&gt;罗德里格旋转公式&lt;/a&gt;，当然这两者完全等价. &lt;/p&gt;
&lt;p&gt;两个坐标系间的旋转矩阵$\mathbf {R}$为：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}{\mathbf {R}}={\mathbf {I}}+(\sin \Theta ){\mathbf {U}}+(1-\cos \Theta ){\mathbf {U}}^{2}\label{4eqrodrig}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;也可写作：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}\mathbf {R} = (\cos \Theta)\mathbf {I} +(\sin \Theta){\mathbf {U}} +(1-\cos \Theta )\mathbf {u} \otimes \mathbf {u}
\label{5eqrodrig}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;仍以大地坐标系到机体坐标系的旋转说明上式: 若$\mathbf{u}$为旋转轴在大地坐标系内的坐标向量, 旋转角度为$\Theta$, 则上式计算结果即为$\mathbf{R_B^G}$.&lt;/p&gt;
&lt;p&gt;上两式中矩阵${\mathbf {U}}$为向量$\mathbf{u}$的&lt;a href="https://en.wikipedia.org/wiki/Cross_product#Conversion_to_matrix_multiplication"&gt;叉积矩阵(cross product matrix)&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;$${\mathbf {U}}={\begin{bmatrix}0&amp;amp;-u_{z}&amp;amp;u_{y}\\
u_{z}&amp;amp;0&amp;amp;-u_{x}\\
-u_{y}&amp;amp;u_{x}&amp;amp;0
\end{bmatrix}}$$&lt;/p&gt;
&lt;p&gt;$\mathbf {u} \otimes \mathbf {u}$为向量$\mathbf {u}$自身的张量积(也可认为是u的行向量与列向量之积):&lt;/p&gt;
&lt;p&gt;$$\mathbf {u} \otimes \mathbf {u} ={\begin{bmatrix}u_{x}^{2}&amp;amp;u_{x}u_{y}&amp;amp;u_{x}u_{z}\\
u_{x}u_{y}&amp;amp;u_{y}^{2}&amp;amp;u_{y}u_{z}\\
u_{x}u_{z}&amp;amp;u_{y}u_{z}&amp;amp;u_{z}^{2}\end{bmatrix}}$$&lt;/p&gt;
&lt;p&gt;由于$\mathbf{u}$为单位向量，可以看出矩阵${\mathbf {U}}^{2}$与矩阵$\mathbf {u} \otimes \mathbf {u}$之差为单位阵，因此$\eqref{4eqrodrig}$与$\eqref{5eqrodrig}$等价. &lt;/p&gt;
&lt;h3 id="1.3"&gt;1.3 姿态误差的求取&lt;/h3&gt;

&lt;p&gt;各姿态轴的误差可通过旋转轴&lt;strong&gt;单位&lt;/strong&gt;向量与旋转角度的乘积给出:&lt;/p&gt;
&lt;p&gt;$$\begin{equation}\mathbf{error} = \begin{pmatrix}
u_x \\ u_y \\ u_z
\end{pmatrix}\Theta
\label{6eqerror}
\end{equation}$$&lt;/p&gt;
&lt;!--**TODO, where do I find the reference矩阵计算形式**--&gt;

&lt;h2 id="2"&gt;2. Pixhawk姿态控制解析&lt;/h2&gt;

&lt;p&gt;有了前面旋转矩阵等相关知识的铺垫，本章节所讲述Pixhawk多旋翼姿态控制就不是特别难了. &lt;/p&gt;
&lt;h3 id="2.1"&gt;2.1 Pixhawk飞控系统框图&lt;/h3&gt;

&lt;p&gt;Pixhawk飞控系统框图可表示如下：
&lt;center&gt;&lt;img src="/images/pixhawk_control_law/2.1control_Arch.png" alt = "control_Arch" /&gt;&lt;/center&gt;
最内层为姿态控制环节，外层依次为位置和航路控制环节. 上图对于多旋翼，固定翼及垂直起降(VTOL)飞机均适用，不同构型飞机飞控的差别在于姿态(Attitude)和位置(Position)的估计(Estimator)和控制(Controller)模块会使用不同的算法，因此会使用不同的模块. 不同构型飞机使用姿态位置估计控制模块可&lt;a href="http://onewayout.github.io/pixhawk/2016/05/24/pixhawk-principle-and-customize.html#1.5"&gt;参考此处的表格&lt;/a&gt;. &lt;/p&gt;
&lt;h3 id="2.2"&gt;2.2 Pixhawk姿态控制解析&lt;/h3&gt;

&lt;p&gt;Pixhawk中多旋翼姿态控制模块对应的源文件为&lt;a href="https://github.com/PX4/Firmware/blob/master/src/modules/mc_att_control/mc_att_control_main.cpp"&gt;Firmware/src/modules/mc_att_control/mc_att_control_main.cpp&lt;/a&gt;. 其关键部分是角度误差控制及角速率误差控制，可表示如下图：
&lt;center&gt;&lt;img src="/images/pixhawk_control_law/2.2attitude_controller.png" alt = "attitude_controller" /&gt;&lt;/center&gt;
角度误差控制和角速率误差控制分别对应于源文件中的&lt;code&gt;control_attitude(float dt)&lt;/code&gt;和&lt;code&gt;control_attitude_rates(float dt)&lt;/code&gt;函数. &lt;br&gt;
此模块中油门(Thrust或Throttle)基本没作控制，以下不讨论. &lt;/p&gt;
&lt;h4 id="2.2.1"&gt;2.2.1 角度误差控制&lt;/h4&gt;

&lt;!--ad.hoc--&gt;

&lt;p&gt;此环节的功能由函数&lt;code&gt;control_attitude(float dt)&lt;/code&gt;完成. 其输入为飞机当前姿态和目标姿态，通过此两姿态的旋转矩阵计算出三个姿态轴的角度误差，进行比例控制，并对航向角度误差(yaw error)另作前馈控制，输出为目标角速率. &lt;br&gt;
此控制环节最难的部分是&lt;strong&gt;如何根据当前姿态和目标姿态两个旋转矩阵计算角度误差&lt;/strong&gt;，此部分完全是&lt;a href="https://groups.google.com/forum/#!topic/px4users/ln3yzqF6Vz0"&gt;开发者Anton Babushkin自己的想法&lt;/a&gt;, 无现成参考论文或资料. 其基本指导思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于多旋翼roll和pitch的较yaw的响应速度快，因此首先控制roll和pitch，使飞机的Z轴与目标姿态Z轴一致，最后旋转z轴，消除yaw偏差, 根据此方法计算出各姿态误差；&lt;/li&gt;
&lt;li&gt;在目标姿态Z轴水平时，由于欧拉角的奇异点(singularity)问题，忽略yaw误差;&lt;/li&gt;
&lt;li&gt;若目标姿态与当前姿态Z轴夹角过大(90~270°), 意味着roll和pitch需要更大的控制量. 此时直接根据四元素计算出各姿态误差; 并将此误差与前面第1种方法计算出的误差取各自权重相加,得到最终各姿态误差.&lt;/li&gt;
&lt;/ol&gt;
&lt;!--**TODO 几个坐标系的图示**  或表格;--&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="n"&gt;MulticopterAttitudeControl&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;control_attitude&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vehicle_attitude_setpoint_poll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;_thrust_sp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_v_att_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;thrust&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* construct attitude setpoint rotation matrix */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_v_att_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;R_body&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* get current rotation matrix from control state quaternions */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Quaternion&lt;/span&gt; &lt;span class="n"&gt;q_att&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_ctrl_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;_ctrl_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;_ctrl_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;_ctrl_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q_att&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_dcm&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* all input data is ready, run controller itself */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此段代码主要是为得到: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前姿态机体坐标系到大地坐标系的旋转矩阵${\mathbf {R_B^G}}$(代码中为&lt;strong&gt;&lt;code&gt;R&lt;/code&gt;&lt;/strong&gt;);&lt;/li&gt;
&lt;li&gt;目标姿态机体坐标系到大地坐标系的旋转矩阵${\mathbf {R_{sp}^G}}$(代码中为&lt;strong&gt;&lt;code&gt;R_sp&lt;/code&gt;&lt;/strong&gt;). &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此所有输入已准备就绪，接下来逐步计算各姿态轴角度误差. &lt;/p&gt;
&lt;p&gt;我们之前提到过，旋转当前机体，以使当前机体的Z轴和目标姿态的Z轴重合，此姿态与目标姿态仅存在yaw误差，姑且称此姿态为&lt;strong&gt;rp姿态&lt;/strong&gt;, 以下代码将计算将从当前姿态旋转到&lt;strong&gt;rp姿态&lt;/strong&gt;的旋转轴. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cm"&gt;/* try to move thrust vector shortest way, because yaw response is slower than roll/pitch */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_z&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_sp_z&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="cm"&gt;/* axis and sin(angle) of desired rotation */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e_R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transposed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R_z&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;R_sp_z&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* calculate angle error */&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;e_R_z_sin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;e_R_z_cos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R_z&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;R_sp_z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cm"&gt;/* calculate weight for yaw control */&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;yaw_w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意代码中&lt;strong&gt;&lt;code&gt;%&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;*&lt;/code&gt;&lt;/strong&gt;运算符已重载, 对向量而言分别是叉乘和点乘, 下同.&lt;br&gt;
根据前面&lt;a href="#1.1"&gt;1.1节&lt;/a&gt;，&lt;strong&gt;&lt;code&gt;R_z&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;R_sp_z&lt;/code&gt;&lt;/strong&gt;分别为当前机体Z轴和目标机体姿态Z轴在大地坐标系中坐标向量. 其叉乘与此两向量垂直，即为使当前机体的Z轴和目标姿态的Z轴重合的旋转的旋转轴在大地坐标系中的向量，与&lt;strong&gt;&lt;code&gt;R.transposed()&lt;/code&gt;&lt;/strong&gt;相乘后，所得&lt;strong&gt;&lt;code&gt;e_R&lt;/code&gt;&lt;/strong&gt;即为此旋转轴在当前机体坐标系内的坐标向量. 根据向量叉乘及点乘定义，容易理解&lt;code&gt;e_R_z_sin&lt;/code&gt;, &lt;code&gt;e_R_z_cos&lt;/code&gt;分别为当前机体Z轴与目标机体Z轴夹角的正弦值和余弦值.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;R_sp(2, 2)&lt;/code&gt;&lt;/strong&gt;为目标机体姿态Z轴与大地z轴夹角的余弦值. &lt;strong&gt;&lt;code&gt;yaw_w&lt;/code&gt;&lt;/strong&gt;将在后面作为一个权重值使用, 稍后解释.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cm"&gt;/* calculate rotation matrix after roll/pitch only rotation */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_rp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e_R_z_sin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* get axis-angle representation */&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;e_R_z_angle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atan2f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e_R_z_sin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e_R_z_cos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e_R_z_axis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;e_R_z_sin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;e_R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R_z_axis&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;e_R_z_angle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* cross product matrix for e_R_axis */&lt;/span&gt;
        &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;e_R_cp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R_z_axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* rotation matrix for roll/pitch only rotation */&lt;/span&gt;
        &lt;span class="n"&gt;R_rp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_I&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;e_R_cp&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;e_R_z_sin&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;e_R_cp&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;e_R_cp&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;e_R_z_cos&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* zero roll/pitch rotation */&lt;/span&gt;
        &lt;span class="n"&gt;R_rp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;e_R_z_sin&lt;/code&gt;为非负值(因叉乘定义中两向量夹角范围为0~180°), 因此若Z轴存在误差, 第6~9行代码计算从当前姿态旋转到rp姿态的旋转轴向量(单位化), 以及旋转角, &lt;code&gt;e_R&lt;/code&gt;即为从当前姿态到rp姿态的各姿态轴误差. 注意这几行代码的向量均在当前姿态坐标系内.&lt;/p&gt;
&lt;p&gt;第12~22行代码即根据此旋转轴和旋转角度, 利用罗德里格旋转公式计算旋转矩阵. 第22行等式右侧最外层括号中即为rp姿态到当前姿态的旋转矩阵, 乘以R后, &lt;strong&gt;&lt;code&gt;R_rp&lt;/code&gt;&lt;/strong&gt;即为rp姿态坐标系至大地坐标系的旋转矩阵. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cm"&gt;/* R_rp and R_sp has the same Z axis, calculate yaw error */&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_sp_x&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R_rp_x&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R_rp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_rp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;R_rp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;e_R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atan2f&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;R_rp_x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;R_sp_x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;R_sp_z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R_rp_x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;R_sp_x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;yaw_w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e_R_z_cos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* for large thrust vector rotations use another rotation method:&lt;/span&gt;
&lt;span class="cm"&gt;         * calculate angle and axis for R -&amp;gt; R_sp rotation directly */&lt;/span&gt;
        &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Quaternion&lt;/span&gt; &lt;span class="n"&gt;q_error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;q_error&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_dcm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transposed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;R_sp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e_R_d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;q_error&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;2.0f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;q_error&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;2.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* use fusion of Z axis based rotation and direct rotation */&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;direct_w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R_z_cos&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;e_R_z_cos&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;yaw_w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;e_R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e_R&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;direct_w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;e_R_d&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;direct_w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此段代码中第2~4行首先计算目标姿态Z轴与当前姿态Z轴误差角度. 前面提到过&lt;code&gt;yaw_w&lt;/code&gt;为目标姿态Z轴与大地坐标系z轴夹角余弦值的平方, 为一权重值. 当两轴夹角为0时, &lt;code&gt;yaw_w&lt;/code&gt;为1; 两轴夹角为90°, 由于欧拉角的奇异点, yaw与pitch重合, 无需控制yaw, 此时&lt;code&gt;yaw_w&lt;/code&gt;为0. 明白这一点, 这三行代码也就不难理解了.&lt;/p&gt;
&lt;p&gt;若目标姿态Z轴与当前姿态Z轴相差角度较小(±90°), 根据旋转两次的方法计算出的e_R向量即为最终的个姿态轴误差向量.&lt;br&gt;
若目标姿态Z轴与当前姿态Z轴相差角度较大(90~270°), 可仅考虑一次旋转(不需要中间的rp姿态), 利用四元数直接计算三轴误差角度.&lt;/p&gt;
&lt;p&gt;第9~11行代码通过四元数计算出从当前姿态到目标姿态的旋转轴和旋转角度, 从而直接得出三个姿态轴的误差角度向量&lt;strong&gt;&lt;code&gt;e_R_d&lt;/code&gt;&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;第14~15行代码: 将通过两种不同方法计算出的误差角度向量&lt;strong&gt;&lt;code&gt;e_R_d, e_R&lt;/code&gt;&lt;/strong&gt;以各自权重组合, 计算得到最终的误差角度向量(此处不是特别明白).&lt;/p&gt;
&lt;p&gt;至此, 已完全计算得出姿态轴角度误差, 接下来根据此误差计算出目标角速率.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cm"&gt;/* calculate angular rates setpoint */&lt;/span&gt;
    &lt;span class="n"&gt;_rates_sp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;att_p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e_R&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* limit rates */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_velocity_enabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_manual_enabled&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;constrain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;auto_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;auto_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;constrain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mc_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mc_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* weather-vane mode, dampen yaw rate */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_v_att_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable_mc_yaw_control&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_velocity_enabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_manual_enabled&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;auto_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vtol_wv_yaw_rate_scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;constrain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;// prevent integrator winding up in weathervane mode&lt;/span&gt;
        &lt;span class="n"&gt;_rates_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* feed forward yaw setpoint rate */&lt;/span&gt;
    &lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;_v_att_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yaw_sp_move_rate&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;yaw_w&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yaw_ff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* weather-vane mode, scale down yaw rate */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_v_att_sp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disable_mc_yaw_control&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_velocity_enabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_v_control_mode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flag_control_manual_enabled&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;auto_rate_max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vtol_wv_yaw_rate_scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;constrain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_rates_sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wv_yaw_rate_max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;// prevent integrator winding up in weathervane mode&lt;/span&gt;
        &lt;span class="n"&gt;_rates_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码相对比较简单, 对角度误差进行比例控制得到目标角速率, 进行饱和抑制, 并对yaw另单独进行前馈控制. &lt;/p&gt;
&lt;h4 id="2.2.2"&gt;2.2.2 角速率误差控制&lt;/h4&gt;

&lt;p&gt;上节中我们已经得到目标角速率, 当前角速率可由姿态估计模块给出, 角速率误差控制环节的输入即为此两角速率. 输出为各姿态轴控制命令. 对照代码容易看出其控制框图如下, 此处不再列出源代码:
&lt;center&gt;&lt;img src="/images/pixhawk_control_law/2.3control_rates.png" alt = "control_rates" /&gt;&lt;/center&gt;
此处需要注意除了&lt;span style="color: Green;"&gt;前馈环节&lt;/span&gt;以外, 图中&lt;span style="color: Red;"&gt;PI控制器&lt;/span&gt;以及&lt;span style="color: Blue;"&gt;微分环节&lt;/span&gt;并不是典型的PID控制器, 因为&lt;span style="color: Blue;"&gt;此微分环节&lt;/span&gt;的输入为当前角速率, 而非角速率误差. 可如此理解&lt;span style="color: Blue;"&gt;此微分环节&lt;/span&gt;的作用, 若当前角加速度过大, 应加以控制使其减小, 即对当前角速率进行微分负反馈. &lt;/p&gt;</content><category term="Pixhawk"></category><category term="控制算法"></category></entry><entry><title>How to customize Pixhawk in your own project</title><link href="https://oneWayOut.github.io/articles/xue-xi-zong-jie/customize_Pixhawk/" rel="alternate"></link><published>2016-05-24T00:00:00+08:00</published><updated>2016-05-24T00:00:00+08:00</updated><author><name>oneWayOut</name></author><id>tag:onewayout.github.io,2016-05-24:/articles/xue-xi-zong-jie/customize_Pixhawk/</id><summary type="html">&lt;p&gt;本文是在ISAE Supaero实习时，应老师要求所写。本来老师要求我对Pixhawk的理解写成文档或PPT,　因刚好在折腾博客，就放在这里了。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Pixhawk is an open-source autopilot platform. In this article, I explained the basic architecture of Pixhawk source code. And how to customize it in your own project.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#0"&gt;0. Prerequisite&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1"&gt;1. Understand Pixhawk source code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.1"&gt;1.1 Install the toolchain and build the code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.2"&gt;1.2 How are the source code directories organized&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.3"&gt;1.3 The boot process&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.4"&gt;1.4 The startup scripts&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#1.5"&gt;1.5 The architecture&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2"&gt;2. How to costumize&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.1"&gt;2.1 A small tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.2"&gt;2.2 Add you own controller&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.3"&gt;2.3 Change the mixer&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#2.4"&gt;2.4 Change the makefile and the startup script&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#3"&gt;3. Try this example&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#3.1"&gt;3.1 How to Try it&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#3.2"&gt;3.2 What I have changed&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="0"&gt;0. Prerequisite&lt;/h2&gt;

&lt;p&gt;It's recommended to use &lt;strong&gt;Ubuntu 14.04 LTS&lt;/strong&gt;, otherwise you may have strange issues.&lt;/p&gt;
&lt;p&gt;Please get familiar with GIT, it's a very powerfull software version control tool.　You can install the GUI tool &lt;code&gt;git cola&lt;/code&gt; (In terminal: apt-get install git-cola) if you are not comfortable with the git commands in terminal.&lt;/p&gt;
&lt;p&gt;SublimeText 3 is a convenient editor to navigate the numerous source files. There is already &lt;a href="https://github.com/PX4/Firmware/blob/master/Firmware.sublime-project"&gt;a project file&lt;/a&gt; in the source folder that you can import to SublimeText. One feature that I used every day is that: Press "Ctrl + p" and type in the filename, and you can find the file you want instantly. &lt;/p&gt;
&lt;h2 id="1"&gt;1. Understand Pixhawk source code&lt;/h2&gt;

&lt;h3 id="1.1"&gt;1.1 Install the toolchain and build the code &lt;/h3&gt;

&lt;p&gt;First you have to install the toolchain by following the steps in &lt;a href="http://dev.px4.io/starting-installing-linux.html"&gt;this webpage&lt;/a&gt;. And then you can build the code and flash it to your PX4 board as &lt;a href="http://dev.px4.io/starting-building.html"&gt;this page&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="1.2"&gt;1.2 How are the source code directories organised &lt;/h3&gt;

&lt;p&gt;After you have cloned the source code repository, you might be scared by so many directories and files. Actually you don't need to know all of them. I list the directory tree below(only the very import directories),　and explain what are in the folders.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Firmware 
├── cmake  
├── msg 
│   └── templates 
│       ├── px4 
│       └── uorb 
├── ROMFS 
│   ├── px4fmu_common 
│   │   ├── init.d 
│   │   ├── logging 
│   │   └── mixers 
│   └── px4fmu_test 
│       ├── init.d 
│       ├── mixers 
│       └── unit_test_data 
└── src 
    ├── drivers 
    ├── examples 
    ├── modules 
    │   ├── attitude_estimator_ekf 
    │   ├── attitude_estimator_q 
    │   ├── bottle_drop 
    │   ├── commander 
    │   ├── controllib_test 
    │   ├── dataman 
    │   ├── ekf2 
    │   ├── ekf2_replay 
    │   ├── ekf_att_pos_estimator 
    │   ├── fw_att_control 
    │   ├── fw_pos_control_l1 
    │   ├── gpio_led 
    │   ├── land_detector 
    │   ├── local_position_estimator 
    │   ├── mavlink 
    │   ├── mc_att_control 
    │   ├── mc_att_control_multiplatform 
    │   ├── mc_pos_control 
    │   ├── mc_pos_control_multiplatform 
    │   ├── muorb 
    │   ├── navigator 
    │   ├── param 
    │   ├── position_estimator_inav 
    │   ├── px4iofirmware 
    │   ├── sdlog2 
    │   ├── segway 
    │   ├── sensors 
    │   ├── simulator 
    │   ├── systemlib 
    │   ├── uavcan 
    │   ├── unit_test 
    │   ├── uORB 
    │   └── vtol_att_control 
    └── systemcmds 
        ├── bl_update 
        ├── config 
        ├── dumpfile 
        ├── esc_calib 
        ├── i2c 
        ├── mixer 
        ├── motor_test 
        ├── mtd 
        ├── nshterm 
        ├── param 
        ├── perf 
        ├── pwm 
        ├── reboot 
        ├── reflect 
        ├── tests 
        ├── top 
        ├── topic_listener 
        ├── usb_connected 
        └── ver 
&lt;/pre&gt;&lt;/div&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Folder&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cmake&lt;/td&gt;
&lt;td&gt;make files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;msg&lt;/td&gt;
&lt;td&gt;uORB msg template, the uORB msg headers are generated from this folder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ROMFS&lt;/td&gt;
&lt;td&gt;startup scripts and mixer files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;drivers, examples, flight control tasks&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src/drivers&lt;/td&gt;
&lt;td&gt;all the drivers: gps, gyro, pwm...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src/examples&lt;/td&gt;
&lt;td&gt;some simple examples help you understand the code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src/modules&lt;/td&gt;
&lt;td&gt;estimators, controllers ....&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src/systemcmds&lt;/td&gt;
&lt;td&gt;some handy commands can be used in Nuttx shell&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As you can see, the source code files are well organised. Though you still need time to get familiar with them.&lt;/p&gt;
&lt;h3 id="1.3"&gt;1.3 The boot process&lt;/h3&gt;

&lt;p&gt;If you power on your Pixhawk board through USB cable or BEC, the LED will flash and the buzzer will play a special tune(you can check the tune meaning &lt;a href="http://ardupilot.org/copter/docs/common-sounds-pixhawkpx4.html"&gt;here&lt;/a&gt;). But you may wander what exactly happen during this process. 
&lt;center&gt;&lt;img src="/images/pixhawk/pixhawk_board.png" alt="pixhawk_board" width="219" height="337" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;When powering on the board, the bootloader will run first. Bootloader is like BIOS in your PC. And it's already in the board when you buy it. So you may never need to bother it. The bootloader will launch the Nuttx Operating System. After some initialization of the hardware, memory... the Nuttx will execute a script file called &lt;strong&gt;"init.d/rcS"&lt;/strong&gt; in function &lt;code&gt;nsh_initscript()&lt;/code&gt; of file &lt;code&gt;nsh_script.c&lt;/code&gt;. You can check the script file folder in &lt;a href="#1.2"&gt;section 1.2&lt;/a&gt;). This is a &lt;strong&gt;very important&lt;/strong&gt; step. By executing this script file, some parameters in the EEPROM will be read, and the corresponding tasks related to these parameters will be launched. I will explain this in the next section.&lt;/p&gt;
&lt;h3 id="1.4"&gt;1.4 The startup scripts&lt;/h3&gt;

&lt;p&gt;Nuttx is like a simplified Linux, moreover it's real time. So the script file is quite the same as Bash script in Linux. You can easily understand it if you know linux well.&lt;/p&gt;
&lt;p&gt;Let's read some lines in &lt;code&gt;ROMFS/px4fmu_common/init.d/rcS&lt;/code&gt; first.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;......
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Try to mount the microSD card.&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# REBOOTWORK this needs to start after the flight control loop&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; mount -t vfat /dev/mmcsd0 /fs/microsd
&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[i] microSD mounted: /fs/microsd&amp;quot;&lt;/span&gt;
    &lt;span class="c1"&gt;# Start playing the startup tune&lt;/span&gt;
    tone_alarm start
&lt;span class="k"&gt;else&lt;/span&gt;
    tone_alarm MBAGP
    &lt;span class="k"&gt;if&lt;/span&gt; mkfatfs /dev/mmcsd0
    &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; mount -t vfat /dev/mmcsd0 /fs/microsd
        &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[i] microSD card formatted&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[i] format failed&amp;quot;&lt;/span&gt;
            tone_alarm MNBG
            &lt;span class="nb"&gt;set&lt;/span&gt; LOG_FILE /dev/null
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;set&lt;/span&gt; LOG_FILE /dev/null
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
......
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At first it will start serial driver and set some parameters, which is not interested by us and not listed here. Then you will see &lt;code&gt;if mount -t vfat /dev/mmcsd0 /fs/microsd&lt;/code&gt;. &lt;code&gt;mount&lt;/code&gt; is a built-in command supported by Nuttx (Linux has the same command). It will try to mount the microSD card. If the return value is true, which means microSD card is mounted successfully,  the &lt;code&gt;echo&lt;/code&gt; will print the result in shell window. And you should hear the buzzer alarm by &lt;code&gt;tone_alarm start&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many similar statements like &lt;code&gt;tone_alarm start&lt;/code&gt;. If you understand this, you will almost know how the script file works and how to modify it to satisfy your own needs. Well, the grammar is simple: &lt;code&gt;command -arguments&lt;/code&gt;, just like the commands in Linux Terminal. &lt;code&gt;tone_alrm&lt;/code&gt; is a command compiled from file &lt;code&gt;tone_alarm.cpp&lt;/code&gt; by some tricks in makefile. If you scrutinise the function &lt;code&gt;tone_alarm_main()&lt;/code&gt; in this file, you will find this command has arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's read another piece of code in this file to see if you have any clue.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;......
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$MODE&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; autostart &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="c1"&gt;#&lt;/span&gt;
    &lt;span class="c1"&gt;# Start the ORB (first app to start)&lt;/span&gt;
    &lt;span class="c1"&gt;#&lt;/span&gt;
    uorb start

    &lt;span class="c1"&gt;#&lt;/span&gt;
    &lt;span class="c1"&gt;# Load parameters&lt;/span&gt;
    &lt;span class="c1"&gt;#&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; PARAM_FILE /fs/microsd/params
    &lt;span class="k"&gt;if&lt;/span&gt; mtd start
    &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nb"&gt;set&lt;/span&gt; PARAM_FILE /fs/mtd_params
    &lt;span class="k"&gt;fi&lt;/span&gt;

    param &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nv"&gt;$PARAM_FILE&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; param load
    &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[param] Loaded: &lt;/span&gt;&lt;span class="nv"&gt;$PARAM_FILE&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[param] FAILED loading &lt;/span&gt;&lt;span class="nv"&gt;$PARAM_FILE&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; param reset
        &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="k"&gt;fi&lt;/span&gt;
......
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can find the commands &lt;code&gt;uorb, mtd, param&lt;/code&gt; in files: &lt;code&gt;uORBMain.cpp, mtd.c, param.c&lt;/code&gt;. You don't need to go deep inside these files right now, anyway we may use this method to scrutinise other files later (For instance: flight control files). This piece of code will just start uORB to provide communication service, and load parameter file &lt;code&gt;mtd_params&lt;/code&gt; which contains airframe configuration, PID parameters, etc. &lt;/p&gt;
&lt;p&gt;I assume you have read through this file. So to summarize, the startup scripts are very important in the boot process. I list the things happened in this process to our concern:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read the parameter file&lt;/li&gt;
&lt;li&gt;Start the sensor drivers (script &lt;code&gt;rc.sensors&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Set and load the mixer corresponding to the airframe parameter &lt;code&gt;SYS_AUTOSTART&lt;/code&gt;, set the pwm channel (script &lt;code&gt;rc.autostart&lt;/code&gt;, this file is generated after you build the code) &lt;/li&gt;
&lt;li&gt;Start the flight tasks corresponding to the airframe parameter &lt;code&gt;SYS_AUTOSTART&lt;/code&gt; (script &lt;code&gt;rc.fw_apps&lt;/code&gt;, &lt;code&gt;rc.mc_apps&lt;/code&gt;, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1.5"&gt;1.5 The architecture&lt;/h3&gt;

&lt;p&gt;All the flight control tasks run in Nuttx system. They communicate with each other through uORB. uORB is a implementation of publish-subscribe pattern.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/pixhawk/pixhawk_arch.png" alt="pixhawk_arch" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
To control a vehicle, you need to navigate to waypoints, estimate the position and attitude, and control the position and attitude by using feedback control theory. That's the idea in pixhawk flight control architecture. 
&lt;center&gt;&lt;img src="/images/pixhawk/pixhawk_feedbackcontrol.png" alt="pixhawk_arch" /&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;These flight control modules are in folder &lt;code&gt;Firmware/src/modules&lt;/code&gt;. I list the  modules used by different airframes below. Actually you can find where they are launched in the startup scripts.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align="left"&gt;Fixed Wing&lt;/th&gt;
&lt;th align="left"&gt;Multi Copter&lt;/th&gt;
&lt;th align="left"&gt;VTOL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Navigator&lt;/td&gt;
&lt;td align="left"&gt;navigator&lt;/td&gt;
&lt;td align="left"&gt;navigator&lt;/td&gt;
&lt;td align="left"&gt;navigator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Estimator&lt;/td&gt;
&lt;td align="left"&gt;ekf_att_pos_estimator&lt;/td&gt;
&lt;td align="left"&gt;attitude_estimator_q &lt;br&gt; position_estimator_inav&lt;/td&gt;
&lt;td align="left"&gt;attitude_estimator_q &lt;br&gt; position_estimator_inav&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Controller&lt;/td&gt;
&lt;td align="left"&gt;fw_att_control &lt;br&gt; fw_pow_control_l1&lt;/td&gt;
&lt;td align="left"&gt;mc_att_control &lt;br&gt; mc_pos_control&lt;/td&gt;
&lt;td align="left"&gt;vtol_att_control &lt;br&gt; mc_att_control &lt;br&gt; mc_pos_control &lt;br&gt; fw_att_control &lt;br&gt; fw_pow_control_l1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;
The architectural overview could be seen &lt;a href="http://dev.px4.io/concept-architecture.html"&gt;here&lt;/a&gt;. The tasks communicate by publishing and subscribing uORB messages. For instance, the messages related to the module &lt;code&gt;attitude_estimator_q&lt;/code&gt; are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Published messages:&lt;ul&gt;
&lt;li&gt;vehicle_attitude&lt;/li&gt;
&lt;li&gt;control_state&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Subscribed messages:&lt;ul&gt;
&lt;li&gt;sensor_combined &lt;/li&gt;
&lt;li&gt;vision_position_estimate &lt;/li&gt;
&lt;li&gt;att_pos_mocap &lt;/li&gt;
&lt;li&gt;airspeed &lt;/li&gt;
&lt;li&gt;parameter_update &lt;/li&gt;
&lt;li&gt;vehicle_global_position&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can check the meaning of these messages in folder &lt;code&gt;Firmware/msg/templates&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="2"&gt;2. How to costumize&lt;/h2&gt;

&lt;h3 id="2.1"&gt; 2.1 A small tutorial &lt;/h3&gt;

&lt;p&gt;We can do a small exercise to understand the code better, and then go even further. Please follow &lt;a href="http://dev.px4.io/tutorial-hello-sky.html#step-2-minimal-application"&gt;this tutorial&lt;/a&gt;. The FTDI 3.3v cable is &lt;strong&gt;a necessary hardware&lt;/strong&gt; for developpers to interact with Nuttx through &lt;strong&gt;Nuttx Shell(NSH)&lt;/strong&gt;. &lt;/p&gt;
&lt;h3 id="2.2"&gt; 2.2 Add you own controller &lt;/h3&gt;

&lt;p&gt;Following the same concept, you can add a simple control law in &lt;a href="https://github.com/PX4/Firmware/tree/master/src/examples/fixedwing_control"&gt;&lt;code&gt;Firmware/src/examples/fixedwing_control/main.c&lt;/code&gt;&lt;/a&gt;. The program subscribes the estimated position and attitude, manual control input. The only thing you need to do is to implement the PID control law, and calculate the &lt;strong&gt;normalized control value&lt;/strong&gt;. Then publish it in the &lt;code&gt;actuator_controls_0&lt;/code&gt; message to mixer to control the servos or motors.&lt;/p&gt;
&lt;h3 id="2.3"&gt; 2.3 Change the mixer &lt;/h3&gt;

&lt;p&gt;The key concept of the mixer is to translate the normalized control output from the controller to pwm to actuators, Which greatly improves reusability of code. If you have a special airframe, you may need to have you own mixer to control the acuators. Please refer to &lt;a href="http://dev.px4.io/concept-mixing.html"&gt;this webpage&lt;/a&gt; and the source file folder &lt;code&gt;Firmware/ROMFS/mixers&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="2.4"&gt; 2.4 Change the makefile and the startup script&lt;/h3&gt;

&lt;p&gt;You can add you own program in &lt;code&gt;Firmware/cmake/configs/nuttx_px4fmu-v2_default.cmake&lt;/code&gt; as you did before in &lt;a href="#2.1"&gt;section 2.1&lt;/a&gt;, so as to compile it. But you still need to launch it in Nuttx shell. An alternative and simple way is to start it in startup script like below (Take fixed wing airframe for instance):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;......
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Start attitude controller&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# fw_att_control start&lt;/span&gt;
&lt;span class="c1"&gt;# fw_pos_control_l1 start&lt;/span&gt;

ex_fixedwing_control start
......
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This piece of code is from &lt;code&gt;rc.fw_apps&lt;/code&gt;. As you can see, two lines are commented, one line is inserted. So your own controller &lt;code&gt;ex_fixedwing_control&lt;/code&gt; from &lt;a href="#2.2"&gt;section 2.2&lt;/a&gt; is started instead of the original one: &lt;code&gt;fw_att_control&lt;/code&gt; and &lt;code&gt;fw_pos_control_l1&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="3"&gt;3. Try this example &lt;/h2&gt;

&lt;p&gt;I have modified some Pixhawk code for my internship project. So you can try my code and use the same method to customize pixhawk in your own project too.&lt;/p&gt;
&lt;p&gt;In my example, the &lt;code&gt;MAIN OUT&lt;/code&gt; channel 1 and 2 can be controlled by the roll angle. And the &lt;code&gt;MAIN OUT&lt;/code&gt; channel 3, 4, 5 and 6 are controlled by vertical speed.&lt;/p&gt;
&lt;h3 id="3.1"&gt;3.1 How to Try it&lt;/h3&gt;

&lt;p&gt;In terminal, go to the folder where you want to store the source code, type in the following commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# clone the repository&lt;/span&gt;
git clone https://github.com/oneWayOut/Firmware.git
&lt;span class="nb"&gt;cd&lt;/span&gt; Firmware
git checkout caidev
git submodule update --init --recursive

&lt;span class="c1"&gt;# please connect pixhawk to your computer through USB cable&lt;/span&gt;
make px4fmu-v2_default upload
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After you have execute the commands above, connect the servo and motor to the &lt;code&gt;MAIN OUT&lt;/code&gt; channels. Connect a FTDI 3.3v cable to pixhawk as explained &lt;a href="http://dev.px4.io/advanced-system-console.html#connecting-via-ftdi-33v-cable"&gt;here&lt;/a&gt;. I assume you have installed &lt;code&gt;screen&lt;/code&gt;. So you can connect to Nuttx shell by the command below(change &lt;code&gt;/dev/ttyXXX&lt;/code&gt; to your own device name, something like &lt;code&gt;/dev/ttyUSB0&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;screen /dev/ttyXXX &lt;span class="m"&gt;57600&lt;/span&gt; 8N1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And start my customized task in Nuttx shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nsh&amp;gt; ex_visionair_control start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Press the safety button to arm the board, now you can observe how the servo and motor react when you change the roll angle and the vertical speed of Pixhawk board. &lt;/p&gt;
&lt;h3 id="3.2"&gt;3.2 What I have changed &lt;/h3&gt;

&lt;p&gt;As I said before, I changed the startup scripts, makefile. And I renamed the folder &lt;code&gt;fixedwing_control&lt;/code&gt; to &lt;code&gt;visionair_control&lt;/code&gt;. In the file &lt;code&gt;main.c&lt;/code&gt; from this folder, I connect the sensor value  directly to pwm channel, but not using mixer.  You can see what I have changed &lt;a href="https://github.com/PX4/Firmware/compare/master...oneWayOut:caidev"&gt;here&lt;/a&gt;.&lt;/p&gt;</content><category term="Pixhawk"></category><category term="UAV"></category></entry><entry><title>图示卡尔曼滤波器原理(译文)</title><link href="https://oneWayOut.github.io/articles/xue-xi-zong-jie/Kalman_Filter/" rel="alternate"></link><published>2016-05-18T00:00:00+08:00</published><updated>2016-05-18T00:00:00+08:00</updated><author><name>oneWayOut</name></author><id>tag:onewayout.github.io,2016-05-18:/articles/xue-xi-zong-jie/Kalman_Filter/</id><summary type="html">&lt;p&gt;本译文结合大量直指核心概念的图片，深入浅出的解释了卡尔曼滤波器的基本原理。&lt;/p&gt;</summary><content type="html">&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
},
messageStyle: "none",
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
&lt;/script&gt;

&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;

&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;最近需要用到卡尔曼滤波器，看了一些文章，发现这篇&lt;a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures"&gt; How a Kalman filter works, in pictures&lt;/a&gt;最为深入浅出，通俗易懂，翻译出来供朋友们参考。
若你发现有任何不当之处请Email至：&lt;a href="mailto:cia120@163.com"&gt;cia120@163.com&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将介绍&lt;a href="https://zh.wikipedia.org/wiki/卡尔曼滤波"&gt;卡尔曼滤波器&lt;/a&gt;，因其在工程中有着广泛应用. &lt;/p&gt;
&lt;p&gt;遗憾的是貌似很少有软件工程师和科学家对其了解。卡尔曼滤波器是一个特别通用和强大的&lt;strong&gt;信息融合&lt;/strong&gt;工具，特别是出现不确定因素时. 其提取精确信息的能力曾一度看起来有些不可思议. 如果说我有些夸大其词，请看&lt;a href="http://www.bzarg.com/p/improving-imu-attitude-estimates-with-velocity-data"&gt;我之前发的一个视频&lt;/a&gt;，这个视频中我演示了卡尔曼滤波器根据一个自由浮动的物体的&lt;em&gt;速度&lt;/em&gt;得出其&lt;em&gt;方位&lt;/em&gt;. 非常巧妙. &lt;/p&gt;
&lt;h1&gt;什么是卡尔曼滤波器?&lt;/h1&gt;
&lt;p&gt;卡尔曼滤波器对于含&lt;strong&gt;不确定信息&lt;/strong&gt;的动态系统均可适用，你可以对系统下一步的行为做一个&lt;strong&gt;有根据的猜测&lt;/strong&gt;. 哪怕实际情况与你的猜测相去甚远，卡尔曼滤波器通常也能计算出实际发生了什么. 并且它能有效利用你可能不会想到的各种极端现象之间的联系. &lt;/p&gt;
&lt;p&gt;对于连续变化的系统，卡尔曼滤波器是十分理想的. 其优势是占用内存少（除了上一个状态，不需要存储其他历史数据），而且速度快，这些优势使其非常适用于实时问题和嵌入式系统. &lt;/p&gt;
&lt;p&gt;Google一下卡尔曼滤波器，搜索到的大部分文章用到的数学知识都看起来晦涩难懂，让人望而却步. 事实上如果你从正确的角度看待它，就会发现卡尔曼滤波器其实超级简单易懂,这使它成为一个很好的文章主题.我将以许多清晰、漂亮的图片以及各色符号来阐述之. 理解本文你仅需的前置知识是懂一些概率论和矩阵. &lt;/p&gt;
&lt;p&gt;我们先从一个不太严谨的例子开始. 如果你想直奔主题到漂亮的图片和数学公式，请&lt;a href="#jump"&gt;跳到这里继续阅读&lt;/a&gt;. &lt;/p&gt;
&lt;h1&gt;卡尔曼滤波器能干什么？&lt;/h1&gt;
&lt;p&gt;我们假定这样一个例子：你组装了一个能在树林中漫步的小机器人，它必须知道自身的确切位置，从而能自主行驶. &lt;/p&gt;
&lt;!--div style="text-align:center"&gt;
&lt;img src="/images/robot_forest-300x160.png" alt="Your little robot" /&gt;
&lt;/div--&gt;

&lt;p&gt;&lt;img alt="Your little robot" class="center" src="/images/robot_forest-300x160.png"&gt;&lt;/p&gt;
&lt;p&gt;我们可以说这个机器人有一个状态向量$\vec{x_k}$，包含位置和速度：&lt;/p&gt;
&lt;p&gt;$$\vec{x_k} = (\vec{p}, \vec{v})$$&lt;/p&gt;
&lt;p&gt;注意状态向量其实就是列出了关于系统组态的一些数字. 在我们的例子中就是位置和速度，根据你所研究的问题不同，它也可能是油箱中液体的体积，汽车引擎的温度，手指在触摸板上的位置等你所关注的任何东西. &lt;/p&gt;
&lt;p&gt;我们的机器人有GPS传感器，其精度约10m，还不错. 但它还需更精确地知道自身位置，树林中遍地沟壑，就算有几十厘米的失误，机器人也可能跌入其中，所以仅靠GPS定位还是不够的. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Oh no." class="center" src="/images/robot_ohnoes-300x283.png"&gt;&lt;/p&gt;
&lt;p&gt;我们可能还能知道关于机器人移动的一些其他信息：发送给驱动轮电机的指令，若其行进方向无障碍，其下一个时刻可能就在这个方向稍远的位置. 当然关于其运动也有些未知因素：机器人可能被强风吹歪，其轮子可能打滑，或在崎岖的地形上翻滚. 因此轮子转动的距离不一定就代表了机器人行进的距离，预测也可能不准. &lt;/p&gt;
&lt;p&gt;GPS能得到关于状态一些东西，但并不直接，并带有不确定和不精确性. &lt;strong&gt;预测&lt;/strong&gt;能得到机器人如何将如何移动，但有同样的局限性. &lt;/p&gt;
&lt;p&gt;如果用上所有这些手头上的信息，能比单独仅用GPS或仅凭预测得到更好的结果吗？答案是肯定的，这就是卡尔曼滤波器的用武之处. &lt;/p&gt;
&lt;p&gt;&lt;span id="jump"&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;卡尔曼滤波器如何看你的问题&lt;/h1&gt;
&lt;p&gt;（&lt;code&gt;译注：下文很多地方将出现估计（estimate）和预测(predict)两词，请注意其区别,前者指根据测量值等已知量估计出所关心的状态变量的值，后者指根据当前状态预测下一时刻的状态.&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;看一下我想阐释的问题，我们继续从这个仅有位置和速度的简单状态向量开始：&lt;/p&gt;
&lt;p&gt;$$\vec{x} = \begin{bmatrix}
p\\
v
\end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;我们并不知道确切的位置和速度，只知道一些位置和速度的可能组合，但其中一些组合的可能性比其他的更大:
&lt;center&gt;&lt;img src="/images/gauss_0.png" width="310" height="325"/&gt;&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;卡尔曼滤波器假定这两个变量（在我们的例子中是位置和速度）是随机且&lt;a href="https://zh.wikipedia.org/wiki/正态分布"&gt;高斯分布&lt;/a&gt;（即正态分布）. 每个变量有一个&lt;strong&gt;平均值&lt;/strong&gt;$\mu$（也就是最可能的状态），以及&lt;a href="https://zh.wikipedia.org/wiki/方差"&gt;&lt;strong&gt;方差(Variance)&lt;/strong&gt;&lt;/a&gt;&lt;em&gt;$\sigma^2$&lt;/em&gt;，方差表示不确定性:（&lt;code&gt;译注：下图中有一小错误，颜色标记的应为标准差，而非方差，否则单位不一致&lt;/code&gt;）
&lt;center&gt;&lt;img src="/images/gauss_1.png" width="310" height="276"/&gt;&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在上图中，位置和速度是&lt;strong&gt;不相关&lt;/strong&gt;的，这意味着你无法从一个变量的状态知道另一个变量的任何信息. &lt;/p&gt;
&lt;p&gt;下图显示了一个稍有趣的例子：位置和速度是&lt;strong&gt;相关&lt;/strong&gt;的，观测到一个特定的位置的可能性取决于此时的速度. 
&lt;center&gt;&lt;img src="/images/gauss_3.png" width="310" height="286"/&gt;&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;当我们以当前位置来预测下一个位置时，这种相关的情况就可能发生. 如果速度较快，下一位置就会更远，反之亦然. &lt;/p&gt;
&lt;p&gt;跟踪这种相关性非常重要，因为这给了我们&lt;strong&gt;更多的信息&lt;/strong&gt;：对一个变量的测量值告诉我们其他变量的可能值. 这就是卡尔曼滤波器的目的，从一些不太确定的测量中尽量挤出更多有用的信息!&lt;/p&gt;
&lt;p&gt;这种相关性可以用&lt;a href="https://zh.wikipedia.org/wiki/协方差矩阵"&gt;协方差矩阵(Covariance matrix)&lt;/a&gt;来量度. 简单来说，该矩阵中每个元素$\Sigma_{ij}$表示了第i个状态变量和第j个状态变量的相关性的程度. （你可能猜得到协方差矩阵是&lt;a href="https://zh.wikipedia.org/wiki/對稱矩陣"&gt;对称阵&lt;/a&gt;，因为交换i,j的次序, 结果相同）. 协方差矩阵通常以符号“$\mathbf{\Sigma}$”表示，因此其每个元素可以“&lt;em&gt;$\Sigma_{ij}$”&lt;/em&gt;表示.
&lt;center&gt;&lt;img src="/images/gauss_2.png" width="310" height="286"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1&gt;用矩阵描述我们的问题&lt;/h1&gt;
&lt;p&gt;若对这个问题中的状态向量建模，我们需要知道在&lt;em&gt;k&lt;/em&gt;时刻的两个信息：最佳估计$\mathbf{\hat{x}_k}$（均值）,
&lt;strong&gt;以及协方差矩阵&lt;/strong&gt;$\mathbf{P_k}$. &lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{eq:statevars} \begin{aligned}\mathbf{\hat{x}}_k &amp;amp;= 
\begin{bmatrix}
\text{position}\\
\text{velocity}
\end{bmatrix}\\
\mathbf{P}_k &amp;amp;=
\begin{bmatrix}
\Sigma_{pp} &amp;amp; \Sigma_{pv} \\
\Sigma_{vp} &amp;amp; \Sigma_{vv} \\
\end{bmatrix}
\end{aligned}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;(此处我们仅使用了位置和速度两个变量，在实际应用中状态向量可包含任意个变量，用来表示你所关心的任何信息). &lt;/p&gt;
&lt;p&gt;接下来，我们很关心如何得到&lt;span style="color: RoyalBlue;"&gt;当前状态&lt;/span&gt;(&lt;span style="color: RoyalBlue;"&gt;&lt;strong&gt;k-1&lt;/strong&gt;&lt;/span&gt;)和预测&lt;span style="color: DeepPink;"&gt;下一状态&lt;/span&gt;(&lt;span style="color: DeepPink;"&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/span&gt;)，注意我们并不知道状态值是否真实，但是预测函数对此并不关心，它仅在所有状态可能性的基础上给出一个新的预测分布：
&lt;center&gt;&lt;img src="/images/gauss_7.jpg" width="310" height="286"/&gt;&lt;/center&gt;
当前状态向量到预测下一步的状态向量的转换可用矩阵$\mathbf{F_k}$表示：
&lt;center&gt;&lt;img src="/images/gauss_8.jpg" width="310" height="286"/&gt;&lt;/center&gt;
从上图可看出，每一个可能的向量$\color{royalblue}{\mathbf{X_{k-1}}}$（原始估计）都可通过矩阵$\mathbf{F_k}$转换到$\color{deeppink}{\mathbf{X_k}}$(预测值), 若原始估计值正确，则系统下一个时刻的状态很可能为预测值. &lt;/p&gt;
&lt;p&gt;在我们这个机器人的小例子中，如何使用矩阵来预测下一时刻的位置和速度呢？使用基本的运动学公式：（这里认为两个时刻的速度近似不变）&lt;/p&gt;
&lt;p&gt;$$\begin{split}
\color{deeppink}{p_k} &amp;amp;= \color{royalblue}{p_{k-1}} + \Delta t
&amp;amp;\color{royalblue}{v_{k-1}} \\
\color{deeppink}{v_k} &amp;amp;= &amp;amp;\color{royalblue}{v_{k-1}}
\end{split}$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$\begin{align} \color{deeppink}{\mathbf{\hat{x}}k} &amp;amp;=
\begin{bmatrix}
1 &amp;amp; \Delta t \\
0 &amp;amp; 1
\end{bmatrix}
\color{royalblue}{\mathbf{\hat{x}}} \\ &amp;amp;= \mathbf{F}k \color{royalblue}{\mathbf{\hat{x}}}\label{statevars} \end{align}$$&lt;/p&gt;
&lt;p&gt;现在我们得出了&lt;strong&gt;预测矩阵&lt;/strong&gt;$\mathbf{F_k}$，能告诉下一个状态；但如何更新协方差矩阵仍未知. &lt;/p&gt;
&lt;p&gt;这里我们需要使用另外一个公式，如果对每一个具有概率分布的点乘以矩阵$\color{firebrick}{\mathbf{A}}$，其协方差矩阵$\Sigma$会如何？&lt;/p&gt;
&lt;p&gt;其实这也不难，如下：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
Cov(x) &amp;amp;= \Sigma\\
Cov(\color{firebrick}{\mathbf{A}}x) &amp;amp;= \color{firebrick}{\mathbf{A}}\Sigma \color{firebrick}{\mathbf{A}}^T
\end{split} \label{covident}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;综合$\eqref{covident}$, $\eqref{statevars}$两式：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{deeppink}{\mathbf{\hat{x}}_k} &amp;amp;= \mathbf{F}_k\color{royalblue}{\mathbf{\hat{x}}_{k-1}} \\
\color{deeppink}{\mathbf{P}_k} &amp;amp;= \mathbf{F_k}\color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T
\end{split}　\label{eq5}
\end{equation}$$&lt;/p&gt;
&lt;h2&gt;外部影响&lt;/h2&gt;
&lt;p&gt;然而我们并未考虑完全，外部环境的某些变化可能&lt;strong&gt;与状态向量不相关&lt;/strong&gt;，但仍能影响系统. &lt;/p&gt;
&lt;p&gt;例如：若上节中的状态向量表示了列车的运动，列车驾驶员可能推动油门，使列车加速. 类似的，在我们的机器人中，导航软件可能发出使轮子转动或停止的指令. 如果知道实际情况中这些额外的信息，我们可以将其放在向量$\color{darkorange}{\vec{\mathbf{u}_k}}$中，利用这个向量对我们的预测做进一步纠正. &lt;/p&gt;
&lt;p&gt;比方说根据油门或控制指令，我们知道预期的加速度$\color{darkorange}{a}$，可以得到：&lt;/p&gt;
&lt;p&gt;$$\begin{split}
\color{deeppink}{p_k} &amp;amp;= \color{royalblue}{p_{k-1}} + {\Delta t}
&amp;amp;\color{royalblue}{v_{k-1}} + &amp;amp;\frac{1}{2} \color{darkorange}{a}
{\Delta t}^2 \\
\color{deeppink}{v_k} &amp;amp;= &amp;amp;\color{royalblue}{v_{k-1}} + &amp;amp;\color{darkorange}{a} {\Delta t}
\end{split}$$&lt;/p&gt;
&lt;p&gt;矩阵的形式如下：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{deeppink}{\mathbf{\hat{x}}_k} &amp;amp;= \mathbf{F}_k\color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \begin{bmatrix}
\frac{\Delta t^2}{2} \\
\Delta t
\end{bmatrix} \color{darkorange}{a} \\
&amp;amp;= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} +\mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}}
\end{split} \label{eq6}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;$\mathbf{B}_k$称之为&lt;strong&gt;控制矩阵&lt;/strong&gt;，$\color{darkorange}{\vec{\mathbf{u}_k}}$为&lt;strong&gt;控制向量&lt;/strong&gt;. （对于简单无外部干扰的系统，可忽略这两者）&lt;/p&gt;
&lt;p&gt;我们可以加入更多细节，但若预测模型并非100%准确将会发生什么？&lt;/p&gt;
&lt;h2&gt;外部不确定性&lt;/h2&gt;
&lt;p&gt;如果状态向量按照其固有属性发展，一切好说（可利用公式$\eqref{eq5}$）. 如果系统在有外界力的作用下发展，只要我们知道这些力，仍没问题(利用式$\eqref{eq6}$). &lt;/p&gt;
&lt;p&gt;但如果我们不知道这些力，怎么办？例如，强风的影响，轮子打滑，路面颠簸. 我们无法对这些全部考虑，而这些事情会导致我们的预测失灵. &lt;/p&gt;
&lt;p&gt;通过给每一步预测添加表示不确定的量，我们可以给环境的这种不确定性建模：
&lt;center&gt;&lt;img src="/images/gauss_9.jpg" width="310" height="286"/&gt;&lt;/center&gt;
如上图所示，k-1时刻的估计值$\color{royalblue}{\mathbf{\hat{x}}_{k-1}}$经过预测步骤后，可能以协方差$\color{mediumaquamarine}{\mathbf{Q}_k}$移动至&lt;span style="color: Purple;"&gt;紫色&lt;/span&gt;高斯斑点（Gaussian blob）内某个位置，也可以说将未知的环境影响视为协方差为$\color{mediumaquamarine}{\mathbf{Q}_k}$的&lt;strong&gt;噪音&lt;/strong&gt;. 
&lt;center&gt;&lt;img src="/images/gauss_10a.jpg" width="310" height="310"/&gt;&lt;/center&gt;
这将产生一个新的高斯斑点，但有不同的协方差（相同的平均值）：
&lt;center&gt;&lt;img src="/images/gauss_10b.jpg" width="310" height="310"/&gt;&lt;/center&gt;
简单地&lt;strong&gt;加上&lt;/strong&gt;$\color{mediumaquamarine}{\mathbf{Q}_k}$，能得到&lt;strong&gt;预测步骤&lt;/strong&gt;的完整表达式：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{deeppink}{\mathbf{\hat{x}}_k} &amp;amp;= \mathbf{F}_k\color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \mathbf{B}_k\color{darkorange}{\vec{\mathbf{u}_k}} \\
\color{deeppink}{\mathbf{P}_k} &amp;amp;= \mathbf{F_k}\color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T +\color{mediumaquamarine}{\mathbf{Q}_k}
\end{split}
\label{kalpredictfull}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;也就是说，&lt;span style="color: DeepPink;"&gt;新的最佳估计&lt;/span&gt;是对&lt;span style="color: RoyalBlue;"&gt;上一步最佳估计&lt;/span&gt;的&lt;strong&gt;预测&lt;/strong&gt;，并加上考虑&lt;span style="color: DarkOrange;"&gt;已知的外界影响&lt;/span&gt;后的&lt;strong&gt;修正量&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;&lt;span style="color: DeepPink;"&gt;新的不确定性&lt;/span&gt;是从&lt;span style="color: RoyalBlue;"&gt;上一步的不确定性&lt;/span&gt;&lt;strong&gt;预测&lt;/strong&gt;得来，并加上&lt;span style="color: MediumAquamarine;"&gt;环境的额外不确定性&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;如此一来就很简单了，通过$\color{deeppink}{\mathbf{\hat{x}}_k}$，$\color{deeppink}{\mathbf{P}_k}$，我们有对系统的模糊估计. 下一步我们将看看当从传感器读数据时，实际上发生了什么？&lt;/p&gt;
&lt;h1&gt;利用测量改善估计&lt;/h1&gt;
&lt;p&gt;我们可能有一些能给出系统状态信息的传感器. 目前它们能测什么没什么关系，可能有的传感器能测位置，有的能测速度. 每个传感器能&lt;strong&gt;间接地（indirect）&lt;/strong&gt;给出状态的某些信息，也就是说，传感器对系统状态进行某种操作，从而给出&lt;strong&gt;读数&lt;/strong&gt;. 
&lt;center&gt;&lt;img src="/images/gauss_12.jpg" width="621" height="286"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;注意到传感器读数的单位和比例与我们所关心的系统状态的单位比例可能不同，你可能猜得到，我们以矩阵$\mathbf{H}_k$给传感器这种行为建模. 
&lt;center&gt;&lt;img src="/images/gauss_13.jpg" width="621" height="286"/&gt;&lt;/center&gt;
我们可以弄明白传感器读数的分布：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{aligned}
\vec{\mu}_{\text{expected}} &amp;amp;= \mathbf{H}_k\color{deeppink}{\mathbf{\hat{x}}_k} \\
\mathbf{\Sigma}_{\text{expected}} &amp;amp;= \mathbf{H}_k\color{deeppink}{\mathbf{P}_k} \mathbf{H}_k^T
\end{aligned}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;卡尔曼滤波器很棒的一点就是能处理传感器噪音. 噪音是指传感器总是有一些不可靠之处，原始估计中的每个状态会产生一系列可能的读数. 
&lt;center&gt;&lt;img src="/images/gauss_14.jpg" width="621" height="286"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根据观测到的每个读数，我们可以猜测系统处于某个特定的状态. 但由于有一些不确定性，一些状态比其他状态更具可能性，这些更具可能性的状态就产生了我们看到的读数:
&lt;center&gt;&lt;img src="/images/gauss_11.jpg" width="310" height="286"/&gt;&lt;/center&gt;
我们将此不确定性(例如传感器噪音)的&lt;strong&gt;协方差&lt;/strong&gt;称为$\color{mediumaquamarine}{\mathbf{R}_k}$，此分布的&lt;strong&gt;均值&lt;/strong&gt;就是我们观测到的读数$\color{yellowgreen}{\vec{\mathbf{z}_k}}$. &lt;/p&gt;
&lt;p&gt;现在我们有两个高斯斑点，一个的中心是预测的转换（$\mathbf{H}_k\color{deeppink}{\mathbf{\hat{x}}_k}$）后的均值，另一个的中心是传感器读数($\color{yellowgreen}{\vec{\mathbf{z}_k}}$). 
&lt;center&gt;&lt;img src="/images/gauss_4.jpg" width="310" height="286"/&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;对于系统状态现在可以从两个途径猜测，一个是基于从&lt;span style="color: DeepPink;"&gt;&lt;strong&gt;上一状态的预测&lt;/strong&gt;&lt;/span&gt;（式$\eqref{kalpredictfull}$），另一个是根据&lt;strong&gt;传感器读数&lt;/strong&gt;，我们必须兼顾调和这两个猜测. &lt;/p&gt;
&lt;p&gt;那么最有可能的新系统状态是什么？对于我们看到的读数$(z_1,z_2)$，实际上有两种相关的可能性：&lt;span style="color: YellowGreen;"&gt;（1）&lt;/span&gt;传感器读数$\color{yellowgreen}{\vec{\mathbf{z}_k}}$测出了$(z_1,z_2)$的值，&lt;span style="color: DeepPink;"&gt;（2）&lt;/span&gt;从上一步估计推测出此时系统的状态，此估计产生了我们看到的读数. &lt;/p&gt;
&lt;p&gt;如果有这两种可能性，而我们想知道这两种都正确的几率，只需要将其相乘：
&lt;center&gt;&lt;img src="/images/gauss_6a.png" width="310" height="286"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重叠的区域&lt;/strong&gt;最具可能性. 这比任何单独一种的预测精确得多. 此分布的均值就是上述两种估计都最具可能性的值，因而也就是在所有给定信息基础上的&lt;strong&gt;最佳猜测&lt;/strong&gt;. 这看起来很像另外一个高斯分布. 
&lt;center&gt;&lt;img src="/images/gauss_6.png" width="310" height="286"/&gt;&lt;/center&gt;
事实证明，若将两个具有不同均值和协方差矩阵的高斯分布相乘，会得到一个具有新均值及新协方差矩阵的高斯分布. 下文将讲述此转换过程中各高斯分布参数间关系. &lt;/p&gt;
&lt;h1&gt;组合高斯分布&lt;/h1&gt;
&lt;p&gt;从最简单的一维高斯分布开始，均值为$\mu$， 方差为&lt;em&gt;$\sigma^2$&lt;/em&gt;的&lt;strong&gt;一维高斯分布&lt;/strong&gt;可定义如下：&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{gaussformula}
\mathcal{N}(x, \mu,\sigma) = \frac{1}{ \sigma \sqrt{ 2\pi } }
e^{ -\frac{ (x – \mu)^2 }{ 2\sigma^2 } }
\end{equation}$$&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{gaussequiv}
\mathcal{N}(x, \color{fuchsia}{\mu_0},\color{deeppink}{\sigma_0}) \cdot \mathcal{N}(x,\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\sigma_1})\stackrel{?}{=} \mathcal{N}(x, \color{royalblue}{\mu’},\color{mediumblue}{\sigma’})
\end{equation}$$&lt;/p&gt;
&lt;p&gt;我们想知道将两个高斯分布相乘会得到什么？
&lt;center&gt;&lt;img src="/images/gauss_joint.png" width="589" height="381"/&gt;&lt;/center&gt;
将$\eqref{gaussformula}$式代入$\eqref{gaussequiv}$式并进行一些代数运算（注意需对新的分布作归一化处理，以使其总概率为1），可以得到：&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{fusionformula}
\begin{aligned}
\color{royalblue}{\mu’} &amp;amp;= \mu_0 + \frac{\sigma_0^2 (\mu_1 –\mu_0)} {\sigma_0^2 + \sigma_1^2}\\
\color{mediumblue}{\sigma’}^2 &amp;amp;= \sigma_0^2 –\frac{\sigma_0^4} {\sigma_0^2 + \sigma_1^2}
\end{aligned}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;通过引入系数$\color{purple}{\mathbf{k}}$，可将上式简化:&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{gainformula}
\color{purple}{\mathbf{k}} = \frac{\sigma_0^2}{\sigma_0^2 +\sigma_1^2}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{royalblue}{\mu’} &amp;amp;= \mu_0 + &amp;amp;\color{purple}{\mathbf{k}}
(\mu_1 – \mu_0)\\
\color{mediumblue}{\sigma’}^2 &amp;amp;= \sigma_0^2 –
&amp;amp;\color{purple}{\mathbf{k}} \sigma_0^2
\end{split} \label{update}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;看这公式多简洁！我们能在之前的估计基础上加上一些东西，从而得到新的估计. &lt;/p&gt;
&lt;p&gt;这几个公式的矩阵版本是怎样的呢？只需将$\eqref{gainformula}$和$\eqref{update}$以矩阵的形式重写就可以了. 
若$\Sigma$为高斯分布的协方差矩阵，$\vec{\mu}$为其均值，则有：&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{matrixgain}
\color{purple}{\mathbf{K}} = \Sigma_0 (\Sigma_0 +\Sigma_1)^{-1}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{royalblue}{\vec{\mu}’} &amp;amp;= \vec{\mu_0} +
&amp;amp;\color{purple}{\mathbf{K}} (\vec{\mu_1} – \vec{\mu_0})\\
\color{mediumblue}{\Sigma’} &amp;amp;= \Sigma_0 –
&amp;amp;\color{purple}{\mathbf{K}} \Sigma_0
\end{split} \label{matrixupdate}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;将$\color{purple}{\mathbf{K}}$矩阵称为&lt;strong&gt;卡尔曼增益&lt;/strong&gt;，后面将会用到它. &lt;/p&gt;
&lt;p&gt;简单吧，我们还有一点点就学完了！&lt;/p&gt;
&lt;h1&gt;综上所述&lt;/h1&gt;
&lt;p&gt;我们有两个分布：预测值的测量$(\color{fuchsia}{\mu_0},\color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k\mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k\mathbf{H}_k^T})$；
观测到的测量$(\color{yellowgreen}{\mu_1},\color{mediumaquamarine}{\Sigma_1}) =
(\color{yellowgreen}{\vec{\mathbf{z}_k}},\color{mediumaquamarine}{\mathbf{R}_k})$. 将他们代入$\eqref{matrixupdate}$中：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{aligned}
\mathbf{H}_k \color{royalblue}{\mathbf{\hat{x}}_k’} &amp;amp;=\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} &amp;amp; + &amp;amp;\color{purple}{\mathbf{K}} (\color{yellowgreen}{\vec{\mathbf{z}_k}} –\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\
\mathbf{H}_k \color{royalblue}{\mathbf{P}_k’} \mathbf{H}_k^T &amp;amp;=\color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} &amp;amp; – &amp;amp;\color{purple}{\mathbf{K}} \color{deeppink}{\mathbf{H}_k\mathbf{P}_k \mathbf{H}_k^T}
\end{aligned} \label {kalunsimplified}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;从$\eqref{matrixgain}$式，得到卡尔曼增益是：&lt;/p&gt;
&lt;p&gt;$$\begin{equation} \label{eq:kalgainunsimplified}
\color{purple}{\mathbf{K}} = \color{deeppink}{\mathbf{H}_k\mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k\mathbf{P}_k \mathbf{H}_k^T} +\color{mediumaquamarine}{\mathbf{R}_k})^{-1}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;可将$\eqref{kalunsimplified}$中等式左侧的$\mathbf{H}_k$，$\mathbf{H}_k^T$都消掉，从而简化为：&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\begin{split}
\color{royalblue}{\mathbf{\hat{x}}_k’} &amp;amp;=\color{fuchsia}{\mathbf{\hat{x}}_k} &amp;amp; + &amp;amp;\color{purple}{\mathbf{K}’} (\color{yellowgreen}{\vec{\mathbf{z}_k}} –\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\
\color{royalblue}{\mathbf{P}_k’} &amp;amp;= \color{deeppink}{\mathbf{P}_k}
&amp;amp; – &amp;amp; \color{purple}{\mathbf{K}’} \color{deeppink}{\mathbf{H}_k\mathbf{P}_k}
\end{split}
\label{kalupdatefull}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\color{purple}{\mathbf{K}’} = \color{deeppink}{\mathbf{P}_k\mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k\mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}
\label{kalgainfull}
\end{equation}$$&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;更新步骤&lt;/strong&gt;的完整方程.
$\color{royalblue}{\mathbf{\hat{x}}_k’}$是新的最佳估计，我们可以持续将此值以及$\color{royalblue}{\mathbf{P}_k’}$反馈给新的一轮又一轮的&lt;strong&gt;更新&lt;/strong&gt;与&lt;strong&gt;预测&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/kalflow.png" style="zoom:80%"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;以上所有数学公式中，你仅需实现式$\eqref{kalpredictfull}, \eqref{kalupdatefull}$, 及 $\eqref{kalgainfull}$.（或者直接从$\eqref{covident}$, $\eqref{matrixupdate}$式推导）&lt;/p&gt;
&lt;p&gt;通过这些公式，你可准确地对任何线性系统建模，对于非线性系统，通过对预测及测量的平均值作简单的线性化处理，可使用&lt;strong&gt;扩展卡尔曼滤波器(Extended Kalman Filter)&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;本文参考了&lt;a href="http://www.cl.cam.ac.uk/~rmf25/papers/Understanding%20the%20Basis%20of%20the%20Kalman%20Filter.pdf"&gt;这篇好文&lt;/a&gt;，有探索精神的朋友可在此文中看到更深入的推导. &lt;/p&gt;</content><category term="卡尔曼滤波器"></category><category term="Kalman Filter"></category></entry></feed>